*** Javascript
#+begin_src emacs-lisp
;;      (use-package js2-mode
;;        :commands js2-mode
;;        :init
;;          (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
;;        :config
;;        (progn 
;;          (bind-key "C-x C-e" 'js-send-last-sexp js2-mode-map)
;;          (bind-key "C-M-x" 'js-send-last-sexp-and-go js2-mode-map)
;;          (bind-key "C-c b" 'js-send-buffer js2-mode-map)
;;          (bind-key "C-c C-b" 'js-send-buffer-and-go js2-mode-map)
;;          (bind-key "C-c l" 'js-load-file-and-go js2-mode-map)))
#+end_src

*** Magit - nice git interface

#+begin_src emacs-lisp
(defun sacha/magit-commit-all ()
  "Publish the current file and commit all the current changes."
  (interactive)
  (sacha/org-publish-maybe)
  (magit-status default-directory)
  (magit-stage-all)
  (call-interactively 'magit-log-edit))

(use-package magit
  :init (setq magit-diff-options '("-b")) ; ignore whitespace
  :bind (("C-x v d" . magit-status) 
         ("C-x v p" . magit-push) 
         ("C-x v c" . sacha/magit-commit-all)))
#+end_src
*** Tag files

    I don't often use a TAGS file, but when I do, I don't want to have
    to set my tags file per project. I search for it in the directory
    tree instead.
    
    #+begin_src emacs-lisp
      (defun sacha/recursive-find-file (file &optional directory)
        "Find the first FILE in DIRECTORY or its parents."
        (setq directory (or directory (file-name-directory (buffer-file-name)) (pwd)))
        (if (file-exists-p (expand-file-name file directory))
            (expand-file-name file directory)
          (unless (string= directory "/")
            (sacha/recursive-find-file file (expand-file-name ".." directory)))))
      
      (defun sacha/find-tags ()
        "Set the TAGS file."
        (set (make-variable-buffer-local 'tags-table-list) nil)
        (set (make-variable-buffer-local 'tags-file-name) 
             (sacha/recursive-find-file "TAGS")))
      
      (eval-after-load 'drupal-mode
        '(progn
           (add-hook 'drupal-mode-hook 'sacha/find-tags)))
      #+end_src
*** Projects

#+begin_src emacs-lisp
;;(setq projectile-keymap-prefix (kbd "C-c C-p")) 
;;(use-package projectile
;;  :init 
;;  (progn
;;    (projectile-global-mode)
;;    (setq projectile-enable-caching t)))
;;(use-package helm-projectile)
#+end_src
*** Exploring MELPA recipes

#+begin_src emacs-lisp

#+end_src

** Ledger (personal finance): Make it easier to review my credit card transactions

#+begin_src emacs-lisp
;;(defun sacha/ledger-go-to-beginning-of-entry ()
;;  "Move to the beginning of the current entry."
;;  (while (and (not (bobp))
;;              (eq (ledger-context-line-type (ledger-context-at-point))
;;                  'acct-transaction))
;;    (forward-line -1)))
;;
;;(defun sacha/ledger-entry-date ()
;;  "Returns the date of the entry containing point or nil."
;;  (save-excursion
;;    (sacha/ledger-go-to-beginning-of-entry)
;;    (let ((context-info (ledger-context-other-line 0)))
;;      (when (eq (ledger-context-line-type context-info) 'entry)
;;        (goto-char (line-beginning-position))
;;        (if (looking-at "\\([-0-9\\./]+\\)")
;;            (match-string-no-properties 1))))))
;;
;;(defun sacha/ledger-guess-mbna ()
;;  "Adds a sub-account for the dates for my credit card transactions."
;;  (interactive)
;;  (save-excursion
;;    (sacha/ledger-go-to-beginning-of-entry)
;;    (forward-line 1)
;;    (let ((amount 0) (date (sacha/ledger-entry-date)) month)
;;      (if (string-match "[0-9]+[-\\.]\\([0-9]+\\)[-\\.]\\([0-9]+\\)" date)
;;          (setq month (string-to-number (match-string 1 date))))
;;      ;; Is this a payment or a charge?
;;      (save-excursion
;;        (while (and (eq (ledger-context-line-type (ledger-context-at-point))
;;                        'acct-transaction)
;;                    (not (eobp)))
;;          (let ((context (ledger-context-at-point)))
;;            (if (ledger-context-field-value context 'amount)
;;                (if (string-match "MBNA" (ledger-context-field-value context 'account))
;;                    (setq amount (string-to-number (ledger-context-field-value context 'amount)))
;;                  (setq amount (- (string-to-number (ledger-context-field-value context 'amount)))))))
;;          (forward-line 1)))
;;      (save-excursion
;;        (while (and (eq (ledger-context-line-type (ledger-context-at-point))
;;                        'acct-transaction)
;;                    (not (eobp)))
;;          (let ((context (ledger-context-at-point)))
;;            (if (string-match "MBNA" (ledger-context-field-value context 'account))
;;                (if (re-search-forward "\\(MBNA\\)[ \t]*[-$\.0-9]*[ \t]*$" (line-end-position) t)
;;                    (replace-match
;;                     (concat "MBNA:"
;;                             (elt
;;                              '("January" "February" "March" "April" "May" "June" "July" "August" "September" "October" ;;"November" "December")
;;                              (% (+ (if (> amount 0) 10 11) month) 12)))
;;                             t t nil 1))))
;;          (forward-line 1))))))
#+end_src

** Internet Relay Chat

   IRC is a great way to hang out with other Emacs geeks.
   #+begin_src emacs-lisp
     (use-package erc
       :config
       (setq erc-autojoin-channels-alist '(("freenode.net"
					    "#org-mode"
					    "#hacklabto"
					    "#emacs"))
	     erc-server "irc.freenode.net"
	     erc-nick "sachac"))
   #+end_src

** Self-tracking, statistics, and other data transformations
*** Quantified Awesome
<<clock-in>>

#+begin_src emacs-lisp
;;  (defun sacha/org-clock-in-and-track ()
;;    "Start the clock running. Clock into Quantified Awesome."
;;    (interactive)
;;    (if (derived-mode-p 'org-agenda-mode) (org-agenda-clock-in) (org-clock-in))
;;    (call-interactively 'sacha/org-quantified-track))
;;  (define-key org-agenda-mode-map "!" 'sacha/org-clock-in-and-track)
;;
;;  (defun sacha/org-quantified-track (&optional category note)
;;    "Create a tracking record using CATEGORY and NOTE.
;;  Default to the current task in the agenda, the currently-clocked
;;  entry, or the current subtree in Org."
;;    (interactive (list nil nil))
;;    (let ((get-info 
;;           (lambda ()
;;             (setq category (or category
;;                                (org-entry-get-with-inheritance "QUANTIFIED")))
;;             (unless category
;;               (setq category (read-string "Category: "))
;;               (org-set-property "QUANTIFIED" category))
;;             (setq note (or note (elt (org-heading-components) 4))))))
;;      (unless (and category note)
;;        (cond
;;         ((derived-mode-p 'org-agenda-mode)
;;          (let* ((marker (org-get-at-bol 'org-marker))
;;                 (buffer (marker-buffer marker))
;;                 (pos (marker-position marker)))
;;            (with-current-buffer buffer
;;              (save-excursion
;;                (save-restriction
;;                  (widen)
;;                  (goto-char pos)
;;                  (funcall get-info))))))
;;         ((org-clocking-p)(save-excursion (org-clock-goto) (funcall get-info)))
;;         ((derived-mode-p 'org-mode) (funcall get-info)))
;;        (setq note (or note (read-string "Note: "))))
;;      (quantified-track (concat category " | " note))))
;;    
;;
;;  (use-package quantified)
#+end_src
*** Compare times and effort estimates
<<compare-time>>

This is for comparing times in column view and in tables.

#+begin_src emacs-lisp
;;  (defun sacha/compare-times (clocked estimated)
;;    (if (and (> (length clocked) 0) estimated)
;;        (format "%.2f"
;;              (/ (* 1.0 (org-hh:mm-string-to-minutes clocked))
;;                 (org-hh:mm-string-to-minutes estimated)))
;;      ""))
;;#+end_src
;;
;;Use with =#+COLUMNS: %40ITEM %17Effort(Estimated){:} %CLOCKSUM=, =#+BEGIN: columnview :hlines 1= ... =#+END:=, and
;;
;;#+begin_src org
;;,#+TBLFM: $4='(sacha/compare-times $3 $2)
#+end_src

*** R

#+begin_src emacs-lisp
  (sacha/package-install 'ess)                
  (use-package ess-site
    :commands R)
#+end_src

*** Workrave
    #+begin_src emacs-lisp
;;    (defvar sacha/workrave-file (expand-file-name ".\\Workrave\\historystats" (getenv "AppData")))
;;
;;(defun sacha/workrave-transform-statistics (&optional file)
;;  (interactive (list sacha/workrave-file))
;;  (with-current-buffer (find-file-noselect file)
;;  ;; D day month-1 year hour min day month-1 year hour min
;;    (let ((result "Date\tStart\tEnd\tClicks\tKeystrokes\n"))
;;      (goto-char (point-min))
;;      (while (re-search-forward "^D \\(.*\\)" nil t)
;;	(let ((dates (split-string (match-string 1))))
;;	  (if (re-search-forward "^m \\(.*\\)" nil t)
;;	      (let ((info (split-string (match-string 1))))
;;		(setq result
;;		      (concat result
;;			      (format "%d-%d-%s\t%s:%02d\t%s:%02d\t%s\t%s\n"
;;				      (+ 1900 (string-to-number (elt dates 2))) ; year
;;				      (1+ (string-to-number (elt dates 1))) ; month
;;				      (elt dates 0) ; day
;;				      (elt dates 3) ; start hour
;;				      (string-to-number (elt dates 4)) ; start min
;;				      (elt dates 8) ; end hour
;;				      (string-to-number (elt dates 9)) ; end min
;;				      (elt info 5) ; clicks
;;				      (elt info 6) ; keystrokes
;;				      )))))))
;;      (if (interactive-p)
;;	  (kill-new result)
;;	result))))
    #+end_src
*** Blog
#+begin_src emacs-lisp
;;  (defun sacha/strip-blog-share ()
;;    (interactive)
;;    (let (base)
;;      (save-excursion
;;        (goto-char (point-min))
;;        (while (re-search-forward 
;;                "<div class=\"sharedaddy sd-sharing-enabled\">.*?<div class=\"sharing-clear\"></div></div></div></div>" ;;nil t)
;;          (replace-match "")))))
;;#+end_src
*** Artrage

#+begin_src emacs-lisp
;;          (defun sacha/artrage-export-png (directory &optional prefix)
;;            "Change an Artrage script file (arscript) to export images to DIRECTORY. 
;;      If PREFIX is specified, use that instead of image-."
;;            (interactive "MPath: ")
;;            (unless (file-directory-p directory)
;;              (make-directory directory t))
;;            (while (re-search-forward "[0-9\\.]+s" nil t)
;;              (replace-match "0.000s"))
;;            (goto-char (point-min))
;;            (while (search-forward "<StrokeEvent>" nil t)
;;              (replace-match (concat 
;;                              "EvType: Command    CommandID: ExportLayer    Idx: -1    Channels: NO    Path: \""
;;                              directory
;;                              "/" (or prefix "image-")
;;                              ".png\"
;;  <StrokeEvent>") t t)))
    
#+end_src
** Workarounds
*** color-theme sometimes comes across lists. Odd!

#+begin_src emacs-lisp
  (defadvice face-attribute (around sacha activate)
    (if (symbolp (ad-get-arg 0))
        ad-do-it))
#+end_src

*** ido-sort-mtime stopped working when I upgraded to Windows 8

#+begin_src emacs-lisp
;;  (defadvice ido-sort-mtime (around sacha activate)
;;    (setq ido-temp-list
;;          (sort ido-temp-list 
;;                (lambda (a b)
;;                  (let ((ta (or (nth 5 (file-attributes (concat ido-current-directory a))) '(0 0)))
;;                        (tb (or (nth 5 (file-attributes (concat ido-current-directory b))) '(0 0))))
;;                    (if (= (nth 0 ta) (nth 0 tb))
;;                        (> (nth 1 ta) (nth 1 tb))
;;                      (> (nth 0 ta) (nth 0 tb)))))))
;;    (setq ad-return-value
;;          (ido-to-end  ;; move . files to end (again)
;;           (delq nil (mapcar
;;                      (lambda (x) (if (string-equal (substring x 0 1) ".") x))
;;                      ido-temp-list)))))
;;  
#+end_src
*** Cygwin mogrify doesn't work for me, but ImageMagick does

#+begin_src emacs-lisp
;;(setq eimp-mogrify-program "c:/Program Files/ImageMagick-6.8.3-Q16/mogrify.exe")
#+end_src

** Advanced stuff / things I tend to forget about
*** Editing multiple things
**** Multiple cursors mode					      :drill:
     SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       o2b:61b0ffae-669b-4360-98fd-a6f0ea6f018e
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 2
    :DRILL_FAILURE_COUNT: 1
    :DRILL_AVERAGE_QUALITY: 2.5
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

I often define keyboard macros to process multiple lines in a region.
Maybe =multiple-cursors= will be an even better way. Looks promising!
[[http://emacsrocks.com/e13.html][See Emacs Rocks episode 13 (multiple-cursors) for a great demo]].

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind 
     (("C->" . mc/mark-next-like-this)
      ("C-<" . mc/mark-previous-like-this)
      ("C-*" . mc/mark-all-like-this)))
#+end_src

Thanks to [[http://irreal.org/blog/?p=1733][Irreal]] and [[http://planet.emacsen.org/][Planet Emacsen]] for the link!

**** All							      :drill:
     SCHEDULED: <2013-03-03 Sun>
     :PROPERTIES:
     :ID:       211c02ab-9a9c-4e81-bc95-ce8e48db67b1
     :DRILL_LAST_INTERVAL: 3.86
     :DRILL_REPEATS_SINCE_FAIL: 2
     :DRILL_TOTAL_REPEATS: 3
     :DRILL_FAILURE_COUNT: 2
     :DRILL_AVERAGE_QUALITY: 2.333
     :DRILL_EASE: 2.36
     :DRILL_LAST_QUALITY: 3
     :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
     :END:

M-x all lets you edit all lines matching a given regexp.

#+begin_src emacs-lisp
(use-package all)
#+end_src

*** Edit list   :drill:
    SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       e9147cb0-bad0-421c-9396-4f9045d6ebbb
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 3
    :DRILL_FAILURE_COUNT: 2
    :DRILL_AVERAGE_QUALITY: 2.333
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

M-x edit-list makes it easier to edit an Emacs Lisp list.

#+begin_src emacs-lisp
(use-package edit-list
  :commands edit-list)
#+end_src

*** Ace Jump mode  :drill:
    :PROPERTIES:
    :ID:       56f173e7-d2a2-4589-84d7-c6b435c8a5f8
    :DRILL_LAST_INTERVAL: 0.0
    :DRILL_REPEATS_SINCE_FAIL: 1
    :DRILL_TOTAL_REPEATS: 3
    :DRILL_FAILURE_COUNT: 2
    :DRILL_AVERAGE_QUALITY: 1.667
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 0
    :DRILL_LAST_REVIEWED: [2013-03-13 Wed 09:50]
    :END:

Quickly jump to a position in the current view.

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :bind ("M-SPC" . ace-jump-mode))
  (bind-key "M-S-SPC" 'just-one-space)
#+end_src

Ace Window looks useful too.

#+begin_src emacs-lisp
(use-package ace-window
  :bind ("M-s a w" . ace-window))
#+end_src

*** Network: TRAMP and editing files over SSH
Emacs lets you edit files on remote servers, which is pretty darn
cool. On Windows, these things help a little.

#+begin_src emacs-lisp
(setq tramp-default-method "plink")
(setq tramp-auto-save-directory "c:\\sacha\\tmp")
#+end_src

** Other nifty Emacs things I want to learn
*** Finding the closest Makefile				      :drill:
   SCHEDULED: <2013-03-05 Tue>
   :PROPERTIES:
   :ID:       bfdaf129-f64c-49be-8848-a0e0300fdfdb
   :DRILL_LAST_INTERVAL: 4.14
   :DRILL_REPEATS_SINCE_FAIL: 2
   :DRILL_TOTAL_REPEATS: 1
   :DRILL_FAILURE_COUNT: 0
   :DRILL_AVERAGE_QUALITY: 5.0
   :DRILL_EASE: 2.6
   :DRILL_LAST_QUALITY: 5
   :DRILL_LAST_REVIEWED: [2013-03-01 Fri 16:47]
   :END:

Look up the directory hierarchy from FILE for a file named NAME.
Stop at the first parent directory containing a file NAME,
and return the directory.  Return nil if not found.

**** Answer
=find-dominating-file=


*** iedit

#+begin_src emacs-lisp
(use-package iedit)
#+end_src
   
*** Smartparens mode						      :drill:

#+begin_src emacs-lisp
;;  (use-package smartparens
;;    :init 
;;    (progn
;;      (require 'smartparens-config)
;;      (add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
;;      (add-hook 'emacs-lisp-mode-hook 'show-smartparens-mode)
;;
;;  ;;;;;;;;;;;;;;;;;;;;;;;;
;;      ;; keybinding management
;;  
;;      (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
;;      (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)
;;  
;;      (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
;;      (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
;;      (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
;;      (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)
;;  
;;      (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
;;      (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
;;      (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
;;      (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)
;;  
;;      (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
;;      (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)
;;  
;;      (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
;;      (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)
;;  
;;      (define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
;;      (define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)
;;  
;;      (define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
;;      (define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
;;      (define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
;;      (define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)
;;  
;;      (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
;;      (define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
;;      (define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
;;      (define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)
;;  
;;      (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
;;      (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
;;      (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)
;;  
;;      (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
;;      (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)
;;  
;;      (define-key sp-keymap (kbd "H-t") 'sp-prefix-tag-object)
;;      (define-key sp-keymap (kbd "H-p") 'sp-prefix-pair-object)
;;      (define-key sp-keymap (kbd "H-s c") 'sp-convolute-sexp)
;;      (define-key sp-keymap (kbd "H-s a") 'sp-absorb-sexp)
;;      (define-key sp-keymap (kbd "H-s e") 'sp-emit-sexp)
;;      (define-key sp-keymap (kbd "H-s p") 'sp-add-to-previous-sexp)
;;      (define-key sp-keymap (kbd "H-s n") 'sp-add-to-next-sexp)
;;      (define-key sp-keymap (kbd "H-s j") 'sp-join-sexp)
;;      (define-key sp-keymap (kbd "H-s s") 'sp-split-sexp)
;;  
;;  ;;;;;;;;;;;;;;;;;;
;;      ;; pair management
;;  
;;      (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
;;  
;;  ;;; markdown-mode
;;      (sp-with-modes '(markdown-mode gfm-mode rst-mode)
;;        (sp-local-pair "*" "*" :bind "C-*")
;;        (sp-local-tag "2" "**" "**")
;;        (sp-local-tag "s" "```scheme" "```")
;;        (sp-local-tag "<"  "<_>" "</_>" :transform 'sp-match-sgml-tags))
;;  
;;  ;;; tex-mode latex-mode
;;      (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
;;        (sp-local-tag "i" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;<" ;;"1d5f8e69396c521f645375107197ea4dfbc7b792quot;>"))
;;  
;;  ;;; html-mode
;;      (sp-with-modes '(html-mode sgml-mode)
;;        (sp-local-pair "<" ">"))
;;  
;;  ;;; lisp modes
;;      (sp-with-modes sp--lisp-modes
;;        (sp-local-pair "(" nil :bind "C-("))))
#+end_src
** Web browsing

	 Minor tweak for Firefox on Windows. Otherwise I get "Searching for
	 program" "permission denied" "firefox".
	 
	 #+begin_src emacs-lisp
	 (setq browse-url-firefox-program
         "C:/Program Files (x86)/Mozilla Firefox/firefox.exe")
	 #+end_src
** Startup
   #+begin_src emacs-lisp
;;     (find-file "~/personal/organizer.org")
;;     (require 'org-compat)
;;     (org-agenda nil "a")
	 #+end_src
* Other cool configs you may want to check out
<<links>>

- [[http://doc.norang.ca/org-mode.html][Bernt Hansen]]: Lots of Org-related config. I picked up the graph-drawing stuff from this.
- [[http://bzg.fr/emacs.html][Bastien Guerry]]: Org, Gnus, ERC - Explained in this [[http://sachachua.com/blog/2013/05/emacs-chat-bastien-guerry/][Emacs Chat (~1h)]]
- [[https://github.com/iani/emacs-prelude][Iannis Zannos]]: Explained in this [[https://www.youtube.com/watch?v=0F8aCbC9z3A][Emacs Chat (~1h)]]
- [[https://github.com/magnars/.emacs.d][Magnar Sveen]]: http://whattheemacsd.com/ has some explanations. [[http://sachachua.com/blog/2013/11/emacs-chat-magnar-sveen-emacs-rocks/][Emacs Chat (~1h)]]
- [[https://github.com/jwiegley/dot-emacs][John Wiegley]]: Also see his [[http://www.youtube.com/watch?v=RvPFZL6NJNQ][Emacs Lisp Development talk]] (sorry, sucky video) and [[http://www.youtube.com/watch?v=ytNsHmRLZGM][Emacs Chat video]]

* Inactive/infrequent things
** Beeminder
<<beeminder>>

https://github.com/sachac/beeminder.el

This bit of code lets me track sent messages in Gnus:

#+begin_src emacs-lisp :eval no :tangle no
(defun sacha/beeminder-track-message ()
	(save-excursion
		(goto-char (point-min))
		(when (re-search-forward "Newsgroups: .*emacs")
			(goto-char (point-min))
			(when (re-search-forward "Subject: \\(.*\\)" nil t)
				(beeminder-add-data "orgml" "1" (match-string 1))))))
#+end_src

And this loads the beeminder code:

#+BEGIN_SRC emacs-lisp :eval no :tangle no
(use-package beeminder
  :config (add-hook 'message-send-news-hook 'sacha/beeminder-track-message))
#+END_SRC

** Strike through DONE headlines

I wanted a quick way to visually distinguish DONE tasks from tasks I
still need to do. This [[http://lists.gnu.org/archive/html/emacs-orgmode/2007-03/msg00179.html][handy snippet from the Emacs Org-mode mailing list]] does the trick by striking through the headlines for DONE tasks.

#+begin_src emacs-lisp :tangle no :eval no
(setq org-fontify-done-headline t)
(custom-set-faces
 '(org-done ((t (:foreground "PaleGreen"   
                 :weight normal
                 :strike-through t))))
 '(org-headline-done 
            ((((class color) (min-colors 16) (background dark)) 
               (:foreground "LightSalmon" :strike-through t)))))
#+end_src

** Rainbow delimiters

#+begin_src emacs-lisp  :eval no :tangle no
(use-package rainbow-delimiters
  :init (global-rainbow-delimiters-mode))
#+end_src

** Drupal

#+begin_src emacs-lisp :eval no :tangle no
  (define-derived-mode drupal-mode php-mode "Drupal"
    "Major mode for Drupal source code.
  \\{drupal-mode-map}"
    (setq case-fold-search t) 
    (setq indent-tabs-mode nil)
    (setq c-basic-offset 2)
    (setq indent-tabs-mode nil)
    (setq tab-width 2)
    (setq fill-column 78)
    (c-set-offset 'arglist-cont 0)
    (c-set-offset 'arglist-intro '+)
    (c-set-offset 'case-label 2)
    (c-set-offset 'arglist-close 0)
    (setq yas/buffer-local-condition 
    '(cond
     ((looking-at "\\w") nil)
     ((and
       (not (bobp))
       (or (equal "font-lock-comment-face"
                  (get-char-property (1- (point)) 'face))
           (equal "font-lock-string-face"
                  (get-char-property (1- (point)) 'face))))
      '(require-snippet-condition . force-in-comment))
     (t t))))
  (define-key drupal-mode-map (kbd "TAB") 'indent-according-to-mode)
  (add-hook 'drupal-mode-hook (lambda () (flymake-mode 1)))
  (add-hook 'drupal-mode-hook (lambda () (yas/minor-mode 1)))
  (add-to-list 'auto-mode-alist '("\\.\\(php\\|test\\|module\\|inc\\|install\\|engine\\|profile\\|.theme\\)$" . drupal-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl.php$" . html-helper-mode))
  (define-key drupal-mode-map '[M-S-up] 'flymake-goto-prev-error)
  (define-key drupal-mode-map '[M-S-down] 'flymake-goto-next-error)
  (define-key drupal-mode-map (kbd "C-c C-c") 'comment-dwim)
  
  (defun sacha/drupal-module-name ()
    "Return the Drupal module name for .module and .install files."    (file-name-sans-extension (file-name-nondirectory
                               (buffer-file-name))))
  (add-to-list 'hs-special-modes-alist '(drupal-mode "{" "}" "/[*/]" nil hs-c-like-adjust-block-beginning))
  
#+end_src


** Autoconnect to IRC so that I don't forget

#+begin_src emacs-lisp  :eval no :tangle no
(erc :server "irc.freenode.net" :port 6667 :nick "sachac")
#+end_src
   
** Org - send things to the bottom of the list
Handy for collecting items together.
#+begin_src emacs-lisp :eval no :tangle no
(defun sacha/org-send-to-bottom-of-list ()
  "Send the current line to the bottom of the list."
  (interactive)
  (beginning-of-line)
  (let ((kill-whole-line t))
    (save-excursion
      (kill-liune 1)
      (org-end-of-item-list)
      (yank))))
#+end_src
** Previous weekly review
#+begin_src emacs-lisp
      (defvar sacha/org-quantified-categories 
        '(("Business" 
           ("Earn" . "Business - Earn") 
           ("E1" . "Business - Earn - Consulting - E1") 
           ("Connect" . "Business - Connect") 
           ("Build" . "Business - Build"))
          ("Discretionary"
           ("Social" . "Discretionary - Social")
           ("Productive" . "Discretionary - Productive")
           ("Writing" . "Discretionary - Productive - Writing")
           ("Emacs" . "Discretionary - Productive - Emacs")
           ("Play" . "Discretionary - Play"))
          ("Personal" ;("Biking" . "Personal - Bike")
           ("Routines" . "Personal - Routines"))
          ("Sleep" nil)
          ("Unpaid work" 
           ("Commuting" . "Unpaid work - Subway")
           ("Cook" . "Unpaid work - Cook")
           ("Tidy" . "Unpaid work - Tidy up")))
        "Categories for time summary.")
  
      (defun sacha/org-summarize-time-use (&optional start end)
        (require 'quantified)
        (interactive)
        (unless start (setq start (format-time-string "%Y-%m-%d" (days-to-time (- (time-to-number-of-days base-date) 6)))))
        (unless end (setq end (format-time-string "%Y-%m-%d" (days-to-time (1+ (time-to-number-of-days base-date))))))
        (let ((time-summary (quantified-summarize-time start end))
              (categories sacha/org-quantified-categories)
              result)
          (setq result
                (mapconcat
                 (lambda (a)
                   (if (assoc (car a) time-summary)
                       (concat
                        (format "- %s: %.1f hours" (car a) (/ (cdr (assoc (car a) time-summary)) 3600.0))
                        (if (cdr a)
                            (let ((detail
                                   (delq nil
                                         (mapcar (lambda (b)
                                                   (if (assoc (cdr b) time-summary)
                                                       (format "%s: %.1f"
                                                               (car b)
                                                               (/ (cdr (assoc (cdr b) time-summary)) 3600.0))
                                                     nil))
                                                 (cdr a)))))
                              (if detail
                                  (concat " (" (mapconcat 'identity detail ", ") ")")
                                ""))
                          "")
                        (if (string-equal (car a) "Sleep")
                            (format " - average of %.1f hours per day" (/ (cdr (assoc (car a) time-summary)) 3600.0 7.0))
                          "")
                        "\n")))
           categories ""))
    (if (called-interactively-p)
        (insert result)
      result)))
#+end_src

List upcoming tasks so that I can see if I'm overloaded.

#+begin_src emacs-lisp
  (defun sacha/org-summarize-upcoming-week ()
    "Summarize upcoming tasks as a list."
    (interactive)
    (org-agenda nil "w")
    (let ((string (buffer-string))
          business relationships life)
      (with-temp-buffer
        (insert string)
        (goto-char (point-min))
        (while (re-search-forward sacha/weekly-review-line-regexp nil t)
          (cond
           ((string= (match-string 1) "routines") nil) ; skip routine tasks
           ((string= (match-string 1) "business")
            (add-to-list 'business (concat "  - [ ] " (match-string 3))))
           ((string= (match-string 1) "people")
            (add-to-list 'relationships (concat "  - [ ] " (match-string 3))))
           (t (add-to-list 'life (concat "  - [ ] " (match-string 3)))))))
      (setq string
            (concat
        "*Plans for next week*\n"
        "- Business\n"
        (mapconcat 'identity business "\n")
        "\n- Relationships\n"
        (mapconcat 'identity relationships "\n")
        "\n- Life\n"
        (mapconcat 'identity life "\n")))
      (if (called-interactively-p)
          (kill-new string)
        string)))
#+end_src

This uses Org Agenda's log mode to summarize the tasks that I checked
off. I still need to match it up with the plans for the previous week
to see which items I'd planned ahead, and which ones were new tasks.
(Hmm, is it important to track those separately? I might just skip it.)

#+begin_src emacs-lisp
  (defun sacha/org-summarize-previous-week ()
    "Summarize previously-completed tasks as a list."
    (interactive)
    (save-window-excursion
      (org-agenda nil "w")
      (org-agenda-later -1)
      (org-agenda-log-mode 16)
      (let ((string (buffer-string))
            business relationships life)
        (with-temp-buffer
          (insert string)
        (goto-char (point-min))
        (while (re-search-forward sacha/weekly-review-line-regexp nil t)
          (cond
           ((string= (match-string 1) "routines") nil) ; skip routine tasks
           ((string= (match-string 1) "business")
            (add-to-list 'business (concat "  - " (match-string 2))))
           ((string= (match-string 1) "people")
            (add-to-list 'relationships (concat "  - " (match-string 2))))
           (t (add-to-list 'life (concat "  - " (match-string 2)))))))
      (setq string
            (concat
             "*Accomplished this week*\n\n"
             "- Business\n"
             (mapconcat 'identity business "\n")
             "\n- Relationships\n"
             (mapconcat 'identity relationships "\n")
             "\n- Life\n"
             (mapconcat 'identity life "\n")))
      (if (called-interactively-p)
          (kill-new string)
        string))))

    #+end_src

** Animation for Emacs chats

#+begin_src emacs-lisp
(defun sacha/animate-emacs-chat ()
  (interactive)
  (text-scale-set 6)
  (erase-buffer)
  (sit-for 3)
  (let ((list '("Emacs Chat: Sacha Chua"
                "interviewed by Bastien Guerry"
                ""
                "July 24, 2013"
                "sachachua.com/emacs-chat"))
        (approx-width 41)
        (approx-height 16)
        row)
    (setq row (/ (- approx-height (length list)) 2))
    (mapcar
     (lambda (x)
       (animate-string x
                       row
                       (/ (- approx-width (length x)) 2))
       (setq row (1+ row)))
     list)))
#+end_src

** Idle timer

This snippet is from John Wiegley -
http://lists.gnu.org/archive/html/emacs-orgmode/2010-03/msg00367.html.
It shows the org agenda when Emacs is idle.

Thanks to winner-mode, I can get back to my previous buffers with C-c
left.
#+begin_src emacs-lisp :eval no :tangle no
(defun jump-to-org-agenda ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (if (setq wind (get-buffer-window buf))
            (select-window wind)
          (if (called-interactively-p)
              (progn
                (select-window (display-buffer buf t t))
                (org-fit-window-to-buffer)
                ;; (org-agenda-redo)
                )
            (with-selected-window (display-buffer buf)
              (org-fit-window-to-buffer)
              ;; (org-agenda-redo)
              )))
      (call-interactively 'org-agenda-list)))
  ;;(let ((buf (get-buffer "*Calendar*")))
  ;;  (unless (get-buffer-window buf)
  ;;    (org-agenda-goto-calendar)))
  ;;)

(run-with-idle-timer 300 t 'jump-to-org-agenda)

#+end_src
** Old Flickr/Evernote export

#+begin_src emacs-lisp :eval no :tangle no
       ;; I don't use these as much now that I have the functions above.
       (defun sacha/evernote-extract-links (filename)
         "Extract note names and URLs from an ENEX file."
         (interactive)
         
         (goto-char (point-min))
         (let (list)
           (while (re-search-forward "<title>\\(.+?\\)</title>\\(.*?\n\\)*?.*?href=\"\\(.*?\\)\"" nil t)
             (setq list (cons (cons (match-string-no-properties 1) (match-string-no-properties 3)) list)))
           (delete-region (point-min) (point-max))
           (insert (mapconcat (lambda (x) (concat "- [[" (cdr x) "][" (car x) "]]")) list "\n"))))      
       
       (defun sacha/flickr-extract-this-week ()
         "Extract this week's sketch titles and URLs from the flickr_metadata CSV."
         (interactive)
         (let ((base-date (apply 'encode-time (org-read-date-analyze "-fri" nil '(0 0 0))))
               start end list)
           (setq start (format-time-string "%Y-%m-%d" (days-to-time (- (time-to-number-of-days base-date) 6))))
           (setq end (format-time-string "%Y-%m-%d" (days-to-time (1+ (time-to-number-of-days base-date)))))
           (setq list (csv-parse-buffer t))
           (erase-buffer)
           (insert
            (mapconcat (lambda (x) (concat "- [[" (car x) "][" (cdr x) "]]"))
                       (sort
                        (delq nil
                              (mapcar (lambda (x)
                                        (let ((title (cdr (assoc "FileName" x))))
                                          (if (and (not (string< title start))
                                                   (string< title end))
                                              (cons (cdr (assoc "URL" x)) title))))
                                      list))
                        (lambda (a b) (string<  (cdr a) (cdr b)))
                        )
                       "\n"))))
(set-background-color "blue")
#+end_src
** Presentation code for Emacs Conference
<<emacsconf2013>>

#+begin_src  :eval no :tangle no
  (defvar sacha/org-show-presentation-file "~/Dropbox/Emacs Conference/public.org" "File containing the presentation.")
  (defvar sacha/org-show-slide-tag "slide" "Tag that marks slides.")
  (defvar sacha/org-show-slide-tag-regexp (concat ":" (regexp-quote sacha/org-show-slide-tag) ":"))
  (require 'eimp)
    
  ;; From org-pres--eimp-fit
  (defun sacha/org-show-eimp-fit ()
    "Function used as a hook, fits the image found to the window."
    (when (eq major-mode 'image-mode)
      (eimp-fit-image-to-window nil)))
  (add-hook 'find-file-hook 'sacha/org-show-eimp-fit)
  
  (defun sacha/org-show-execute-slide ()
    "Process slide at point.
    If it contains an Emacs Lisp source block, evaluate it.
    If it contains an image, view it and switch to that buffer.
    Else, focus on that buffer.
    Hide all drawers."
    (interactive)
    (find-file sacha/org-show-presentation-file)
    (org-narrow-to-subtree)
    (visual-line-mode)
    (let ((heading-text (nth 4 (org-heading-components))))
      (cond
       ;; view images
       ((and (goto-char (point-min))
             (re-search-forward "\\[\\[.*\\.\\(jpg\\|gif\\|png\\)" nil t))
        (delete-other-windows)
        (let ((org-link-frame-setup '((file . find-file))))
          (org-open-at-point))
        (delete-other-windows)
        (goto-char (point-min)))
       ;; find and execute source code blocks
       ((and (goto-char (point-min))
             (re-search-forward "#\\+begin_src" nil t))
        (let ((info (org-babel-get-src-block-info)))
          (unwind-protect
              (eval (read (concat "(progn " (nth 1 info) ")"))))))
       (t
        (switch-to-buffer (current-buffer))
        (text-scale-set 4)
        (org-show-subtree)
        (org-cycle-hide-drawers t)
        (org-display-inline-images)
        (delete-other-windows)))
      (set-frame-name heading-text)))
  
  (defun sacha/org-show-next-slide ()
    "Show the next slide."
    (interactive)
    (find-file sacha/org-show-presentation-file)
    (widen)
    (goto-char (line-end-position))
    (when (re-search-forward sacha/org-show-slide-tag-regexp nil t)
      (sacha/org-show-execute-slide)))
  
  (defun sacha/org-show-previous-slide ()
    "Show the next slide."
    (interactive)
    (find-file sacha/org-show-presentation-file)
    (widen)
    (goto-char (line-beginning-position))
    (when (re-search-backward sacha/org-show-slide-tag-regexp nil t)
      (sacha/org-show-execute-slide)))
  
  (global-set-key '[f5] 'sacha/org-show-previous-slide)
  (global-set-key '[f6] 'sacha/org-show-execute-slide)
  (global-set-key '[f7] 'sacha/org-show-next-slide)
#+end_src

** Enable minibuffer completion
[2013-03-31] Superseded by ido-hacks?

It can be difficult to remember the full names of Emacs commands, so I
use =icomplete-mode= for minibuffer completion. This also makes it
easier to discover commands.

#+begin_src emacs-lisp :eval no :tangle no
(icomplete-mode 1)
#+end_src

** Because I'm trying to use helm instead of ido...

*** Ido-mode: Much better navigationy things
[2013-03-31]: Let's try using Helm instead.

Ido-mode is awesome. Let's make it awesomer. I usually want to go to
recently-opened files first.

#+begin_src emacs-lisp :eval no :tangle no
(use-package ido
  :init
  (progn
  (ido-mode 1)
  (setq ido-default-buffer-method 'selected-window)
  (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
  (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
  (defun ido-sort-mtime ()
    (setq ido-temp-list
          (sort ido-temp-list 
                (lambda (a b)
                  (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                        (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                    (if (= (nth 0 ta) (nth 0 tb))
                        (> (nth 1 ta) (nth 1 tb))
                      (> (nth 0 ta) (nth 0 tb)))))))
    (ido-to-end  ;; move . files to end (again)
     (delq nil (mapcar
                (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                ido-temp-list))))))
#+end_src

*** Ido and Org
     
     When I use =org-refile= to organize my notes, I like seeing the
     latest entries on top. Ido-related and verify-related snippets
     are from "Using ido-mode for org-refile (and archiving via
     refile)" in [[http://orgmode.org/worg/org-hacks.html][Org Hacks]].
     
     #+begin_src emacs-lisp :eval no :tangle no
         (setq ido-everywhere t)
         (setq ido-enable-flex-matching t)
         (setq ido-max-directory-size 100000)
         (ido-mode (quote both))
         (setq org-completion-us-ido t)
     #+end_src

*** Finding files

    I don't want to think about directory structures, I just want to
    open files. 

    #+begin_src emacs-lisp  :eval no :tangle no
      (require 'filecache)
      (require 'ido)
      (defun file-cache-ido-find-file (file)
        "Using ido, interactively open file from file cache'.
      First select a file, matched using ido-switch-buffer against the contents
      in `file-cache-alist'. If the file exist in more than one
      directory, select directory. Lastly the file is opened."
        (interactive (list (file-cache-ido-read "File: "
                                                (mapcar
                                                 (lambda (x)
                                                   (car x))
                                                 file-cache-alist))))
        (let* ((record (assoc file file-cache-alist)))
          (find-file
           (expand-file-name
            file
            (if (= (length record) 2)
                (car (cdr record))
              (file-cache-ido-read
               (format "Find %s in dir: " file) (cdr record)))))))
      
      (defun file-cache-ido-read (prompt choices)
        (let ((ido-make-buffer-list-hook
               (lambda ()
                 (setq ido-temp-list choices))))
          (ido-read-buffer prompt)))
      (add-to-list 'file-cache-filter-regexps "docs/html")
      (add-to-list 'file-cache-filter-regexps "\\.svn-base$")
      (add-to-list 'file-cache-filter-regexps "\\.dump$")
    #+end_src     

    To use this code, I add something like
    
    #+begin_src emacs-lisp :tangle no :eval no
      (sacha/file-cache-setup-tree "sacha/proj1" "C-c d"
                                   '("/dir1"
                                     "/dir2"))
    #+end_src
    to my config. Then =C-c d= (or whatever keyboard shortcut I use)
    searches for files within the specified directories.
    
** Keywiz - keyboard quizzes
#+begin_src emacs-lisp :eval no :tangle no
  (use-package keywiz)
  (defun sacha/load-keybindings ()
    "Since we don't want to have to pass through a keywiz game each time..."
    (setq keywiz-cached-commands nil)
    (do-all-symbols (sym)
      (when (and (commandp sym)
                 (not (memq sym '(self-insert-command
                                  digit-argument undefined))))
        (let ((keys (apply 'nconc (mapcar
                                   (lambda (key)
                                     (when (keywiz-key-press-event-p key)
                                       (list key)))
                                   (where-is-internal sym)))))
          ;;  Politically incorrect, but clearer version of the above:
          ;;    (let ((keys (delete-if-not 'keywiz-key-press-event-p
          ;;                               (where-is-internal sym))))
          (and keys
               (push (list sym keys) keywiz-cached-commands))))))
  (sacha/load-keybindings)
  ;; Might be good to use this in org-agenda...
  (defun sacha/random-keybinding ()
    "Describe a random keybinding."
    (let* ((command (keywiz-random keywiz-cached-commands))
           (doc (and command (documentation (car command)))))
      (if command
          (concat (symbol-name (car command)) " "
                  "(" (mapconcat 'key-description (cadr command) ", ") ")"
                  (if doc
                      (concat ": " (substring doc 0 (string-match "\n" doc)))
                    ""))
        "")))
#+end_src

** Work-in-progress: monthly review

... and for good measure, let's do some kind of monthly review too.

#+begin_src emacs-lisp :eval no :tangle no
  (defun sacha/org-prepare-monthly-review ()
    "Prepare monthly review template."
    (interactive)
    (let* ((base-date (org-read-date-analyze "-1m" nil '(0 0 0)))
           (start (encode-time 0 0 0 1 (elt base-date 4) (elt base-date 5)))
           (end (encode-time 0 0 0 1 (1+ (elt base-date 4)) (elt base-date 5))))
      (save-window-excursion
        (kill-new
         (concat
          "*** Monthly review: " (format-time-string "%B %Y" base-date) "  :monthly:\n"
          "*Blog posts*\n\n"
          "*Time review*\n"
          (sacha/org-summarize-time-use
           (format-time-string "%Y-%m-%d" start)
           (format-time-string "%Y-%m-%d" end)
           (float-time (time-subtract end start))
          "\n")))
      (yank))))
#+end_src

** MobileOrg for Android

    I've been playing around with MobileOrg so that I can review my
    agenda and capture notes on my smartphone. My main Org file is too
    big to open easily there, though.
    
#+begin_src emacs-lisp :eval no :tangle no
  (use-package org-mobile
    :init
    (progn
      (autoload 'org-mobile-pull "org-mobile" nil t)
      (autoload 'org-mobile-push "org-mobile" nil t))
    :config
    (progn
      (setq org-mobile-directory "~/Dropbox/mobile")
      (setq org-mobile-inbox-for-pull "~/personal/mobileorg.org")
      (setq default-buffer-file-coding-system 'utf-8)
      (setq org-mobile-files '("/cygdrive/c/sacha/personal/organizer.org"
                               "/cygdrive/c/sacha/personal/business.org"
                               "/cygdrive/c/sacha/personal/books.org"))
      (setq org-mobile-agendas '("a"))))
#+end_src
** Encryption

#+begin_src emacs-lisp :tangle no :eval no
     (require 'org-crypt)
     (org-crypt-use-before-save-magic)
     (setq org-tags-exclude-from-inheritance (quote ("crypt")))

     (setq org-crypt-key nil)
       ;; GPG key to use for encryption
       ;; Either the Key ID or set to nil to use symmetric encryption.

       ;;     (setq auto-save-default nil)
       ;; Auto-saving does not cooperate with org-crypt.el: so you need
       ;; to turn it off if you plan to use org-crypt.el quite often.
       ;; Otherwise, you'll get an (annoying) message each time you
       ;; start Org.

       ;; To turn it off only locally, you can insert this:
       ;;
       ;; # -*- buffer-auto-save-file-name: nil; -*-

#+end_src

* Games
** Typing of Emacs
    #+begin_src emacs-lisp :eval no :tangle no
      (use-package typing
        :init
        (autoload 'typing-of-emacs "typing" nil t)
        :config
        (progn
          (setq toe-starting-length 6)
          (setq toe-starting-time-per-word 2)
          (setq toe-max-length 20)))
#+end_src
** 2048 in Emacs, and colours too																			:emacs:
	 :PROPERTIES:
	 :ID:       o2b:e2b41b2d-463c-4469-91b8-63eb97a13b9d
	 :POST_DATE: [2014-04-16 Wed 23:23]
	 :POSTID:   27182
	 :BLOG:     sacha
	 :END:

While browsing through =M-x list-packages=, I noticed that there was a
new MELPA package that implemented the 2048 game in Emacs. I wrote the
following code to colorize it. Haven't tested the higher numbers yet,
but they're easy enough to tweak if the colours disagree with your
theme. =)

#+begin_src emacs-lisp
  (defface 2048-2-face '((t (:foreground "red"))) "Face used for 2" :group '2048-game)
  (defface 2048-4-face '((t (:foreground "orange"))) "Face used for 4" :group '2048-game)
  (defface 2048-8-face '((t (:foreground "yellow"))) "Face used for 8" :group '2048-game)
  (defface 2048-16-face '((t (:foreground "green"))) "Face used for 16" :group '2048-game)
  (defface 2048-32-face '((t (:foreground "lightblue" :bold t))) "Face used for 32" :group '2048-game)
  (defface 2048-64-face '((t (:foreground "lavender" :bold t))) "Face used for 64" :group '2048-game)
  (defface 2048-128-face '((t (:foreground "SlateBlue" :bold t))) "Face used for 128" :group '2048-game)
  (defface 2048-256-face '((t (:foreground "MediumVioletRed" :bold t))) "Face used for 256" :group '2048-game)
  (defface 2048-512-face '((t (:foreground "tomato" :bold t))) "Face used for 512" :group '2048-game)
  (defface 2048-1024-face '((t (:foreground "SkyBlue1" :bold t))) "Face used for 1024" :group '2048-game)
  (defface 2048-2048-face '((t (:foreground "lightgreen" :bold t))) "Face used for 2048" :group '2048-game)

  (defvar 2048-font-lock-keywords
    '(("\\<2\\>" 0 '2048-2-face)
      ("\\<4\\>" 0 '2048-4-face)
      ("\\<8\\>" 0 '2048-8-face)
      ("\\<16\\>" 0 '2048-16-face)
      ("\\<32\\>" 0 '2048-32-face)
      ("\\<64\\>" 0 '2048-64-face)
      ("\\<128\\>" 0 '2048-128-face)
      ("\\<256\\>" 0 '2048-256-face)
      ("\\<512\\>" 0 '2048-512-face)
      ("\\<1024\\>" 0 '2048-1024-face)
      ("\\<2048\\>" 0 '2048-2048-face)))

  (defun sacha/2048-fontify ()
    (font-lock-add-keywords nil 2048-font-lock-keywords))

  (defun sacha/2048-set-font-size ()
    (text-scale-set 5))

  (use-package 2048-game
    :config
    (progn
     (add-hook '2048-mode-hook 'sacha/2048-fontify)
     (add-hook '2048-mode-hook 'sacha/2048-set-font-size)))
#+end_src


