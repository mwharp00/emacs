Planner
* Configuration
** Publishing
*** Right now just XML -- what's wanted?
*** text vs HTML
*** index? C-c C-a is muse-index
*** publish? C-c C-p runs the command muse-project-publish
*** Use shell script?
*** List tasks
 - > Just to ask once more in case I missed it : whats the best way to
see all > open tasks (past, present and future) regardless of whether
they have a date > assigned?  You should be able to do this with
planner-list-tasks-with-status. The default behavior is to list only
tasks that have a date assigned, but you can change that with the
PAGES argument.
 - C-u M-x planner-list -unfinished-tasks <e> [A-Z] <e>
*** TODO htmlmode
**** need it for both publishing to web and a master task list
*** Previous taskso.txt functionality
+ > 2. When I create a page and want to publish it, I type C-c C-v and
> in the minibuffer I am asked for the project to publish and the
> style. I enter the project name as given in muse_projects_alist in
> .emacs and to which the file is associated. However, I get the
> message 'no pages in nil need publishing at this time' and there is
> no html file of the corresponding muse file.
>
> 3. When type M-x muse-index, the minibuffer says that an index is
> being generated, but I do no see anything like an index or such.

It looks like Muse can't find a project to associate with the current
file.  It normally will never need to prompt for your project, just
the style and output directory (assuming you hit C-c C-t, not C-c
C-v).

Nothing looks wrong with your configuration, though, as long as you
have Muse documents in the ~/documents/labjournal and
~/documents/plans directories.

> 4. Is there a simple may to change into Muse mode and select among
> the projects so that I get to the default page of this project?
> Would it be even possible to (easily) create a function that by
> typing M-x labjournal would open a buffer in the project
> 'labjournal' with the default page open? (I do not know yet how to
> hack lisp code).

Something like the following will work.

(defun my-muse-project-find-file (project)
  (interactive)
  (let ((muse-current-project (muse-project project)))
    (call-interactively 'muse-project-find-file)))

;; Sets C-c p l to bring up Labjournal
(global-set-key "\C-cpl" #'(lambda () (interactive)
                             (my-muse-project-find-file "Labjournal")))

;; Sets C-c p p to bring up Plans
(global-set-key "\C-cpp" #'(lambda () (interactive)
                             (my-muse-project-find-file "Plans")))
+ > I should have been more specific.  I do use the task pool for the
> default place to put tasks, but sometimes I put tasks in more specific
> categories, although I don't assign a date to them.  It would be nice
> if there were a way to access these tasks (spread out over possibly
> multiple plan pages) without a date.  Does that clarify things?

Have you tried a function "planner-list-unfinished-tasks"?
Interactively it only search day pages, but you can call it yourself
with regex matching your "category" pages.
		
** Integration Issues Calendar and diary
*** TODO ck what is loaded
+ planner-calendar.el, etc.
+ decide on diary implentation, note touches remind
*** TODO location and sunrise and sunset
*** TODO cyclic
+ In your .emacs or equivalent:

(require 'planner-cyclic)
(setq planner-cyclic-diary-nag nil)
(setq planner-cyclic-diary-file (concat (planner-directory) "/cyclic_tasks"))

and in cyclic_tasks something like

Monday   #A _ @14:00 Meet Ryan for SciPy discussions

(see Emacs manual for more about diary entries)
* Operation
** Keybindings
*** Move task to page -- planner-multi-task/note-xref
*** I want to from planner create a link to non-existent org file and
    have it created
***  Use Now create file then task from file creates an "annotation" to
     file? How would an anchor work? i.e. # on the previous line?
*** Annotation as kill
+  3. have a function with a name like 'M-x link' that would create a
>     backlink to the current buffer, e-mail or bbdb record, and that
>     would save that link either to the kill ring or to a special
>     buffer (*back-links* for example). If it is saved to the kill ring,
>     it would then be easy to get it back, and if it is a special buffer
>     there would be another function to get back numerous links from that
>     buffer.

I think M-x planner-annotation-as-kill is what you're looking for.
That will put a link to the current buffer in the kill ring.
** TODO Ck for replace task id w/ image
*** Doesn't work - remove planner-id? learn to remove it?
*** perhaps learn to add task id edit and then remove it
*** perhaps ditch concept
**** You don't edit much
**** Can't find delete task-id
** TODO Diary operation and display
*** Print moon phase
*** Diary sunrise and sunset
** TODO Make the file links short w/ M-x muse-edit-link-at-point
*** anchor by hand? # on prev line? 
*** M-x muse-ed does do it
* Philosophy and Usage
** The plan pages vary in functionality
*** People pages for agenda items
*** Some gtd context, some substantive, some reference
*** Relate to Publishing
* Additional Capabilities
** hippie-config.el
** bbdb integration
** planner-appt.el -- read it

I think it is important to keep the two concepts/objectives of muse and planner
distinct in your mind. Muse is a powerful wiki style authoring and publishing
tool which you can quite easily customize to your own requirements (even
creating new publishing styles). Planner is a mode which sits on top of muse
and provides specific extensions that support you in managing and organising
your projects, tasks and other information. 

What I tend to do is use basic muse mode to write up more formal documentation
associated with a specific project. I normally have this in a project specific
directory and define an entry in the project alist that says what publishing
styles to use for this documentation and where to put it. When I've written a
document, I'll use remember to link that document to a planner project page.
I'll also do this with anything else relating to that particular project -
source code, e-mails, web sites etc. This way, I have the planner project page,
which is a summary of all the information relating to this project. It has the
standard planner project page template with tasks, notes and a report section
showing a breakdown of time spent on particular aspects of the project. Within
this page, there will be links to lots of other documents (source code,
documentation, e-mails etc). Often, these links will all be pointing to places
within a distinct directory tree where I work on aspects of that project. For
example, I have the following setup 

~/ -----+- /Plans -- 2007.01.01.muse
        |         |- 2007.01.02.muse
        |         |- 2007.01.03.muse
        |         |- ...
        |         |- TaskPool.muse
        |         |- Project1.muse
        |         |- Project2.muse
        |- /Mail
        |- /News
        |- /Projects -- /Project1 -- /Doc -- ProjectDescription.muse
        |            |            |       |- ProjectPlan.muse
        |            |            |       |- .....
        |            |            |- /Code -- Makefile
        |            |            |        |- HellowWorld.rb
        |            |            |        |- /Tests -- testCode1.rb
        |            |            |- /......
        |            |- /Project2 -- /Doc -- ...
        |            |            |- /Code -- ...
        |            |- ......
        |- /public_html -- Project1 -- ....
        |               |- Project2 -- ....
        |- /tmp

Here, you will find links from the ~/Plans/Project1.muse file to files in the
~/Projects/Project1 subdirectories. There will be a definition in the
muse-project-alist for project 1 that specifies the directory for the project
(i.e. ~/Projects/Project1/Doc), the publishing style (i.e. html), the
publishing directory (~/public_html/Project1) and the document root filename
(i.e. index.html). Any notes, thoughts or ideas I have relating to the project
are put into the ~/Plans/Project1.muse file (usually by using remember). The
actual documentation or write up of the project goes into files within
~/Projects/Project1/Doc). The planner day pages provide a daily breakdown of
things, like meetings and tasks to be performed/started on that day or tracking
time spent on each project. 

for me, the key to all this is to *not* think of planner mode as a project
documentation mode, but instead think of it as a project information
organisation mode. The actual documentation of the project is done using muse
mode - planner just helps organise and track or the bits of information which
tend to come in that relate to the project. It provides convenience functions
to help ensure you don't lose bits of information and to help you plan your
activity and monitor how long you are spending on various projects and project
parts. Essentially, it is about organisation and management of information
rather than creation of documents etc. This is a somewhat mirky distinction and
difficult to express adequately. You may find it useful to look at planner mode
from a different perspective - rather than trying to see how you can
modify/customize planner mode to fit your purposes, see how you can re-organise
how you work to get the most out of planner mode. then, after a few months,
start looking at how planner mode can be customized to fit your purposes. I
only suggest this as it seems from many of yor posts that you are trying to
fight the system and make it do what you want. While this is something that
emacs does well, I think you need to really understand what a package has to
offer and its underlying philosophy before you charge in and try to change it
to fit with your world. This has the advantage that often, you will learn new
ways of doing things which you actually find better that may not have occured
to you otherwise.
> alone and I get a list of task accordling to string I put. For example when
> "Status:" is promped if I type "X" I get alle the executed task from today.
> What I would like is a complete list of task, including which are unscheduled
> (that tend to "disappear" if you don't look inside plans files.
>

Yes, if you give the command a prefix, you can tell it look at plan pages also.
So, do C-u M-x planner-list-unfinished-tasks and give it a pattern to follow,
or just hit RET to search all pages.

==========


I agree that diary and schedule seem synonymous, and I also use just
one of them. Now that I've discovered planner-diary (Happy day!
Thanks, Thomas), I use only the diary and am able to keep an
automatically-updated daily schedule in each day page. For my own
mental reasons, I set planner-diary-string to "* Schedule" -- somehow,
"diary" isn't quite the term I want. As a general observation, the
flexibility of all these tools seems to me such a great strength. Now
that I have some rough idea of how some of this stuff fits together, I
love being able to do something like set planner-diary-string and see
that, aha, it works!
========

and I think it handles hierarchies very well by treating tasks as
specially-marked note subtrees. A task is any tree that has "TODO" in
the headline. This makes it easier to have lots of links in a task.
org.el supports deadlines and timestamps.

Do you think tasks-as-notes would fit the way you work?

* One-line links

I somewhat prefer to inline my links, but org.el has a pretty good
idea: put a link on one line and make it span the whole line. One can
put labels before the links instead of in the [[..][wikidescription]]
part. Downside: org doesn't try to get human-friendly annotations. I
like my "Email to ...." links. Should be easy enough to hack that in,
though.

* Storage

org.el encourages you to store everything in one file. Easy to search,
but could be hard if you have lots of DONE tasks and other items you
don't really use but still need to categorize. Possible approach like
PlannerModeCompletedTasks - split off another tree for archived topics
and just link.

I like planner.el's approach of day pages and plan pages. I can see
stuff from different projects on one day, and all my project-relevant
stuff on the project page.

I guess this could be done as views with org's diary integration.

* Scheduling tasks

I like being able to schedule my tasks for different days so that I'm
not overwhelmed by the list of things I need to do. I'm not yet sure
how to do that with org.el. Timestamps, then chronological view? Tasks
don't get automatically carried forward, though. Deadlines might be
useful, but then I see all future tasks anyway. Hmm. Timestamp start,
then use deadline to remind me if it's passed?

Worth checking out. =)
==============
> and I think it handles hierarchies very well by treating tasks as
> specially-marked note subtrees. A task is any tree that has "TODO" in
> the headline. This makes it easier to have lots of links in a task.
> org.el supports deadlines and timestamps.
>
> Do you think tasks-as-notes would fit the way you work?

I prefer the short tasks - it makes a nice view at the top of each
Daily and Project page.  Burying the todo-s in the page would hide
them.  Yes, you *could* display them like org.el does.  But that
requires volition on my part, and would make it less likely to
happen.   

Again, I'd suggest that if someone needs extensive notes about a
task, they create a note and link it to that.  Perhaps a nice way to
do this would be useful:  planner-create-task-note, which runs
planner-create-task, runs remember with the Task Description as a
headline (and a link to the task at the bottom), and then adds a link
to the task.

i.e. 

-------
#A1  _ Test task ProjectPage#19 {{Tasks:113}} (ProjectPage)
-------

.#19 Test task ([[2004.04.01#5]])

Some random notes about this task.  maybe an extended free-form todo.
[[Task:113]]
-------

Hmm, I guess this also means a new link type (Task)....
 
> * Storage
>
> org.el encourages you to store everything in one file. Easy to search,
> but could be hard if you have lots of DONE tasks and other items you
> don't really use but still need to categorize. Possible approach like
> PlannerModeCompletedTasks - split off another tree for archived topics
> and just link.
>
> I like planner.el's approach of day pages and plan pages. I can see
> stuff from different projects on one day, and all my project-relevant
> stuff on the project page.

I prefer planner.el's methodology too.  Again, an all-in-one file
requires volition on the part of the user to sort information into
relevant categories.  Does it even have a concept of category?  If
not, then the user has to put keywords into every entry.  Planner's
blog style encourages applying a category by asking for a Project
Page and supplies an obvious summary by looking at the Project Page.
Keeping everything in one directory makes using "grep" possible for
more sophisticated data-mining.

> * Scheduling tasks
>
> I like being able to schedule my tasks for different days so that I'm
> not overwhelmed by the list of things I need to do. I'm not yet sure
> how to do that with org.el. Timestamps, then chronological view? Tasks
> don't get automatically carried forward, though. Deadlines might be
> useful, but then I see all future tasks anyway. Hmm. Timestamp start,
> then use deadline to remind me if it's passed?

org.el would be a pretty big step backwards in this regards for me.  

It *does* claim to have the ability to output LateX-like math in the
html output.  That would be quite useful!

Cheers,  Jody

=============

>There's a planner-update-note in planner-experimental.el . Check it
>out, but very carefully -- no guarantees! <laugh> If you like it and
>it seems to work, drop me a note and I'll merge it into the main
>planner.el.

Hmmm, that seemed to do BadThings to my project page buffer :(

I went from having a * Tasks and * Notes, both with stuff in them, to 
just having what was _under_ the * Notes header, but no actual header.
========
Fear not! Your buffer had just been narrowed. At least I think that's
what happened, as it's what happened over here. <sheepish grin> I used
M-x widen to confirm everything was still all right.

I've added a couple of save-restriction and save-excursions, so
planner--dev--1.0--patch-18 should behave as expected. I used the
function and my notes got properly updated.

Sorry for freaking you out. Hope that helps! Please check it out so
that I can merge it in. =)
==========

!/usr/bin/perl

# change this variable to where your planner files are
my $planDir = "/Users/fixra/Plans";

# read in wikiword style files only
opendir(DIR, $planDir);
my @files = grep { /^([A-Z][a-z]+){2,}$/ } readdir(DIR);
closedir(DIR);

# make the file writeable
chmod 0666, "$planDir/Index";

open OUT, ">$planDir/Index" or die("couldn't open $planDir/Index");

print OUT "* Open Tasks by Project\n";
print OUT "** THIS FILE WAS AUTOMATICALLY GENERATED -- DO NOT EDIT\n\n";

my $file;
foreach $file (@files)
{
     # Print the File name... this will make a link that we can jump
to and
     # change the tasks on that page
     print OUT "$file\n";

     open(IN, $planDir."/".$file) or die("can't process $planDir/$file");
     while( $line = <IN> )
     {
         print OUT $line if ($line =~ /^#[ABC]\d+\s+_\s+/)
     }
     close IN;
     print OUT "\n";
}

# make the file read only
chmod 0444, "$planDir/Index";
============
I have found a work-around.

The default diary file appears to be "~/diary.planner", but I have my
diary information in "~/diary".  If I use customize-group "planner" to
change planner-diary-file to "~/diary", then planner-diary still looks
for "~/diary.planner".  But, if I add

(setq planner-diary-file "~/diary")

to the end of my .emacs, then everything seems to work OK.
=============
> Although this works, is there a way to make this a global choice
> rather than going and adding it to every page?  I can't help feeling
> that there just has to be, but I haven't been able to find it yet!

(setq emacs-wiki-style-sheet " <link rel=\"stylesheet\" type=\"text/css\" href=\"adds/style.css\">");

works for me.
============

For a screenshot
http://opg1.ucsd.edu/~jklymak/PlannerMode.html
=========

muse is the way emacs-wiki should probably be. It carries the markup
idea further and does fancier things with it, like the nested
directories and multiple publishing things that people have been
asking for on this list. Working with emacs-wiki, I miss a number of
things from muse, like easy-to-use page directives. Hacking emacs-wiki
into something that resembles muse more is kinda pointless, as, well,
muse is already muse. <grin> (That said, I steal ideas from muse on
occasion.)
=========
> Could you elaborate on that John?  The wiki-ness of emacs-wiki is,
> for me, a huge part of its coolness. What exactly is the wiki-ness
> that one loses on moving to muse from emacs-wiki?

The main wiki-ness detail is MixedCase causing automatic link
creation.  In Muse, a link is always done with [[target][desc]], or
just [[target]].  Of course, muse-wiki.el is intended to add all of
this functionality back in -- I just haven't finished it yet.

The other wiki-ness features involve project grep'ing, finding
backlinks, supported Web editing of pages...
=============
> emacs-wiki now walks subdirectories, thanks to Gary Vaughan's
> hierarchical directories patch. =) You might want to check it out.

Ah, that would be very easy to add, with a ":recurse t" keyword in the
project definition...
============
When I use set-variable debug-on-error t, I get the following output:

<debug>
Debugger entered--Lisp error: (wrong-type-argument....blah
===========

(defun planner-switch-buffer-today ()
  "Switch buffer to planner-today"
  (interactive)
  (if (get-buffer (planner-today))
      (ido-visit-buffer (planner-today) ido-default-buffer-method)
    (planner-goto (planner-today))))
============

#anchorname
** Some task

#A0 _ Some task [[SomePage#anchorname]] (2004.07.15)

more details here...

*** Other details

#A0 _ Some undated task

You can use M-x planner-jump-to-link on a task to jump to a linked
date or plan page in the parens.

> Right... oh, wanted to confirm, plain ol' Wiki pages under ~/Plan do
> not interfere in any way with the linked system of daily and project
> pages, right?

They're a separate project. I hardly have any plain wiki pages these
days, though... =)

> * I liked the (similar to planner) dual nature of the entries, in
> that they could be presented as entries of a particular day, or of a
> particular subject

Mmm. Yes, I find that very useful. Planner's dual nature is static,
not dynamic, though. On the plus side, it's available even outside
Emacs. On the downside, updates need to get propagated.

> * I liked the searching ability within topics

planner-search-notes and grep provide that sort of functionality. I
also use remembrance-agent to index my notes.

>   - in order to do anything (searches, concatenate previous records
>   for given subject, etc) within records had to start in a records
>   buffer, which often meant I had to first create a blank record for
>   today, something I frequently didn't want to do

I like how I can use a lot of planner things from anywhere. M-x
planner-create-task-from-buffer and M-x remember are meant to be used
from other buffers, actually.

>   - the reindexing was a bit of a pain as I kept the records tree
>   synchronized between my laptop and main machine using CVS (had to
>   do cvs up; records-admin; in Emacs C-c C-z on both machines to
>   assure sync)

We don't have fancy indexing just yet, so simply synchronizing your
plans directory should do the trick.

>   - for some reason I never got comfortable navigating within
>   records; I think it lacked a good overview of the whole database,
>   and of just the topics... records did have the index page, but due
>   to the ugly to parse links to pages it was not very useful; much
>   better would have been overview generated pages which would list
>   the first line of each entry with the link

That's a pretty good idea. There are a number of ways to view an
overview of the records, primarily day-oriented.
planner-notes-index.el lists note titles by day. I need to revive
planner-summary.el at some point in time; that was fun too.
planner-tasks-overview.el gives you tasks, and planner-report does
something similar.

To get an overview of the notes in a page, you could use the contents
tag or the usual allout commands.

> Now, there has been work on records AFAIK, and a version 2 is
> pending, but it's been pending for an aweful long time, and it seems
> it's starting to veer towards becoming a weblog tool (rather than
> general record/log keeping), so I'm jumping ship.

Hmm. What do you mean? <curious> Wouldn't it still support
non-chronological note keeping?

planner + remember (using reverse-chronological notes) is close to
being a weblog, and I've hacked in permalinks in my own config.
Still, planner is flexible enough to be used as anything you want. <grin>

> I do have it setup already. Ah, so the note ALWAYS goes on the daily
> page, and only optionally for the project page, I see. From what I
> understand, the note text is duplicated across both pages, right?
> Hmm, this might be a bit too much duplication for my purposes.

If remember-planner-copy-on-xref-flag is nil, the date page will only
contain a note of the form

.#1 Note headline timestamp ([[LinkToPage#1]])

and the full note will be on the plan page.

> Oh! I've forgot to ask: what is the proper way to update the text of
> a note, so that the pages propagate to the other linked (daily or
> project) page?!

There's a planner-update-note in experimental. If it works for you, I
can move it out of experimental. =)
===========
> > I do have it setup already. Ah, so the note ALWAYS goes on the daily
> > page, and only optionally for the project page, I see. From what I
> > understand, the note text is duplicated across both pages, right?
> > Hmm, this might be a bit too much duplication for my purposes.
> 
> If remember-planner-copy-on-xref-flag is nil, the date page will only
> contain a note of the form
> 
> .#1 Note headline timestamp ([[LinkToPage#1]])
> 
> and the full note will be on the plan page.

Puurrrrrfect, thx.
=========
> I could have sworn someone mentioned this function here the other
> day. Does it exist? I couldn't find it. Is it a recent function
> (i.e., do I have update my dev branch?) Or am I halucinating again?

You probably mean planner-annotation-from-planner-note, which only
triggers when your cursor is on a note headline. =)

On TestPage:

* Notes

.#1 Put your pointer here to activate

Elsewhere, it doesn't work.
==============
>>You could probably go the way planner-diary and other
>>section-rewriting modules have gone. Check if the date is today, fetch
>>stuff (unless already fetched), and rewrite the section of your
>>choice. <laugh>
> I'm pretty sure I posted a hack of planner-diary.el that includes the
> contents of an arbitrary wiki page on each day page.  You could easily
> use a cron to fill that page on a daily basis with whatever you want.
> Let me know if you can't find it in the archives.
> Cheers,  Jody

You sent me that code; it's below, and it works great. I have a
CurrentEvents file that looks like this:

** Current: DissSurvey | PlanBetter | TeachPrep

and it gets inserted into each of my day pages right below the date
(which I insert with (buffer-name); is there a better way to do
this?). To move the position, I think you just change
planner-insert-current-projects-title.

-Alan

;; Add a "working on" section...
;; from Jody Klymak
(add-hook 'planner-goto-hook
'planner-insert-current-projects-maybe)

(defun planner-insert-current-projects-maybe (&optional force)
   "Maybe insert the projects for the day into the day plan file.
If the current day is in the past and FORCE is nil, don't do
anything.  If FORCE is non-nil, insert the section even if there"
   (interactive "P")
   (let ((date (planner-diary-get-name)))
     ;; check if we're in a day plan buffer
     (if (and (string-match planner-date-regexp date)
              (or force                    ; don't care about the date
                  (not (string< date (planner-today))))) ; not past
         ;; today, future, or force
         (planner-insert-current-projects force)
       ;; we are in the past -> do nothing, message when interactive
       (when (interactive-p)
         (message "No day plan buffer or date is in the past.  No
diary entries inserted.")))))

(defconst planner-insert-current-projects-page "CurrentProjects");
(defconst planner-insert-current-projects-title "*
<lisp>(buffer-name)</lisp>");

(defun planner-insert-current-projects (&optional force)
   "Insert the fancy diary for the day into the day plan file.
If FORCE is non-nil, insert a diary section even if there is no
`planner-diary-string' in the buffer."
   (interactive "P")
   ;; sanity check
   (save-excursion
     (save-window-excursion
       (goto-char (point-min))
       (or (re-search-forward (concat "^"
planner-insert-current-projects-title "$") (point-max) t)
	  (insert planner-insert-current-projects-title "\n\n"))
       (let ((beg (point))
	    (end (if (re-search-forward "^* " (point-max) t)
		     (progn (beginning-of-line)
			    (backward-char 1)
			    (point))
		   (point-max)))
	    (buf (current-buffer)))
	(delete-region beg end)
	(planner-find-file planner-insert-current-projects-page)
	(set-buffer buf)
	(newline)
	(insert-buffer-substring planner-insert-current-projects-page)
	(newline)
	))))
=========

Of course, I'll continue to keep emacs-wiki-blosxom, read-file-name,
remember-blosxom and planner-calendar up to date, and would be happy to
evaluate contributions from the list.
=========

> Slightly off-topic, this also works well for with publishing.... I
> publish my notes to the web from time to time, and have set up an
> .htaccess file which seperate username/password info for each client
> prefix, so Client1 cannot access the page 'Client2ProjectOne' without a
> 'Client2' password.
============
>> I don't know if there's something similar to emacsclient for Xemacs.
>
> The exact same thing is called "gnuclient" in XEmacs.

It's also available for Gnu Emacs: http://meltin.net/hacks/emacs/ (I
can't connect to it for now).

BTW, it might be possible to use gnuclient to create a task, but I'm
afraid most other mail client won't support an interface to locate a
mail given a message-id.
============
Here's my latest life hack: timing tasks. planner-timeclock.el makes
it easy to keep track of the time you spend on tasks, and Dryice Liu's
planner-timeclock-summary.el gives me a neat wiki-friendly overview.

- Helps me stay focused.
- Shows me how much I can actually do in an hour, which makes me
  want to hack even more things.
- Gives me data for better estimates of future tasks.

Other things I like about my current workflow:

- I use linking _all_ the time. I can't imagine using a PIM that won't
  let me automatically link to e-mail, web pages, and even IRC. I love
  being able to create tasks like "Reply about ..." and have it still
  make sense. Favorite feature next to extreme customizability.

- Creating tasks and notes (with remember) without having to switch
  application totally rocks, too.
  
- I have a few active projects with mostly undated tasks. Now using
  Jody's suggested "automatically schedule the next task from the
  project" lifehack. The code for this can be found in my somewhat
  hairy http://sacha.free.net.ph/notebook/emacs/planner-config.el

What's your favorite lifehack? How do you organize your day?
=================
I wrote spd.el to allow me to switch between my personal journal and my
work tasks & notes.  It's more useful in organizing my notes on my
projects.  I tend to have multiple long-term projects that I'm working
on simultaneously, and I have trouble remembering the status of those I
haven't worked on in a few days.  Remember and Planner-browser are
really handy.  I still haven't "published" anything.

My environment:  Windows 2000, Office 2000, including Outlook for email
and contacts.  (I had Gnus set up to retrieve mail from both Exchange
and my personal POP mailboxes, but it wasn't as intuitive as Outlook.)
I've been using Emacs on Windows since July 2000.
-=========
|> That and a firefox extension to blast URLs into a remember buffer, and
> I'd be an even happier planner user.

This small function is not exactly what you want and I use it to save
some typing:

,----
| ;; planner-yank, yank with [[(yank)][point]], mostly for making links
| ;; from mozilla
| (defun ddliu-planner-yank ()
|   "make a planner link with what's in kill ring"
|   (interactive)
|   (insert "[[")
|   (yank)
|   (insert "][]]")
|   (backward-char 2))
`----

I copy the url from browser, and use this function to past it to
planner, and type in the description myself.
=============

> 1) planner-id could be made standard
> 2) the existing task code could be changed to work via planner-id,
> 3) more than pairs of tasks could be edited at a time.  

I'm in agreement with this. Anyone else care to share opinions? Does
anyone have a reason for not to use planner-id?

As an alternative, we could always add the code to planner-id, or make
planner-multiple.el which required planner-id... However, I'm more in
favour of the integration, simply because I suggest that this is a core
implementation decision not an extra feature.
==========

I limit myself to a few plan pages for miscellany that comes up all
the time.  i.e. "ComputerStuff" pretty well covers all computer
things I need to look up.  I could, of course, have EmacsStuff,
LatexStuff, MatlabStuff, MacStuff, WindowsStuff, CoolUtilities, etc
etc, but then I would not know where to find anything.  Is
ComputerStuff really long?  Sure, but if I am looking for the short
guide to latex "C-s lshort" gets me there in few keystrokes.  

Anyways, thats just how I work.  A few (maybe twelve) plan pages, all
of which are somewhat long.  But now I only have seventeen places to
assign items.  In fact here they are: BooktsToGet, CoastLog (inactive
work), ComputerStuff, CookingPlans, DailyThoughts, FlipLog (work),
GiftIdeas, HealthNotes, HomeLog (work, believe it or not), KnightInlet
(work), MeetingsLog (work), MusicToGet, ProposalsLog (work),
ReadingNotes (work), RevelleLog (work), RevelleProcessing (work).
Thats about all my little brain can handle.  There are, of course, a
few others, but they never get used.
======================

I don't know if I even need the "master pages". Those exist primarily
because I did not start with the dates from the very beginning. I
suppose I have an idea that I assign the most important notes to that
page or something, but I'm not sure I really follow through with that.

I might not like this system if I were publishing my pages. But I'm
not.

Nothing gets lost this way, as tab completion based on the project
name still finds all the pages that need to be checked. I suppose
things could get lost eventually. But for right now, it's working out
pretty well as a way for me to keep from having gargantuan plan pages,
while not forcing me to micro-organize the projects more than I want
to. 
=============
Speaking of planner presentations, I have "Taming the TODO" up at
http://sacha.free.net.ph/notebook/presentations/20041113-taming-the-todo.pdf
=======

The other advantage to planner-create-task-from-buffer,
planner-create-note-from-buffer, and planner-diary-add-entry, is that
they can be called anytime from anywhere in emacs.  The advantage
being that if you come up with an idea, you do not need to leave your
context, find todays page, find where on the page to enter it, and
then get back to where you were.  Planner just does it for you.
========

Also, if you put blank lines between groups of tasks, planner will respect
those boundaries.

========

> the plan pages where all my project notes are. I explained that all they had
> to do was scroll down, but the first impression was bad.  Perhaps the
> indexes for plan and day pages could be separated.

You mean like http://sacha.free.net.ph/notebook/wiki/WikiIndex.php ?
Please load planner-experimental.el and republish your wiki index.
That should probably do the trick. If it works for you too, I can
merge the code into planner.el...
==========
Since you replied to the thread in which support for various email
clients is discussed, let me announce to you that I've published
CopyToClipboard().  This VBA subroutine makes it easy to copy the
contents of an Outlook mail item to the Windows clipboard so that it can
be yanked into an Emacs Planner (or Remember) buffer.  The code is
posted at:

http://www.emacswiki.org/cgi-bin/wiki/PlannerModeContrib
=======
I'm using planner-log-edit.el a lot and it is really great to look at
all the changes I've made at the end of the day :) One problem I've
got is that some of my file/directory names are in CamelCase so they
are rendered as an empty wiki name, which is pretty annoying.

The attached path to planner-log-edit.el add a new variable,
planner-log-edit-quote-filenames, which if is set to t, the
file/directory names will be quoted with "=" so they are no longer
rendered as a wiki name. The variable is set to nil by default to keep
the original behavior.

======================================================================
--- planner-log-edit.el.orig	Mon Dec  6 10:57:22 2004
+++ planner-log-edit.el	Sun Dec 12 23:57:38 2004
@@ -41,6 +41,12 @@
   :type 'boolean
   :group 'planner-log-edit)
 
+(defcustom planner-log-edit-quote-filenames
+  nil
+  "Non-nil means quote the file names with \"=\". "
+  :type 'boolean
+  :group 'planner-log-edit)
+
 (defcustom planner-log-edit-notice-commit-function t
   "Function that should return non-nil if this commit should be noted.
 The function will be run in the log buffer."
@@ -49,6 +55,15 @@
           function)
   :group 'planner-log-edit)
   
+(defun planner-log-edit-quote-maybe ()
+  (if planner-log-edit-quote-filenames
+      (format "=")
+    (format "")))
+
+(defun planner-log-edit-quote-file-maybe (arg)
+  (format "%s%s%s" (planner-log-edit-quote-maybe) arg
+	  (planner-log-edit-quote-maybe)))
+
 (defun planner-log-edit-add-note ()
   "Add a note describing the commit to the current planner page."
   (let* ((buffer (current-buffer))
@@ -64,11 +79,14 @@
           (save-window-excursion
             (planner-create-note nil)
             (insert "Commit"
-                    (when module-name (concat " in " module-name)))
+                    (when module-name (concat " in "
+					      (planner-log-edit-quote-maybe)
+					      module-name
+					      (planner-log-edit-quote-maybe))))
             (newline)
             (when planner-log-edit-include-files-flag
               (insert "Files: ")
-              (insert (mapconcat 'identity files " "))
+              (insert (mapconcat 'planner-log-edit-quote-file-maybe files " "))
               (newline)(newline))
             (insert-buffer-substring buffer))))))
====================================================================== 

Thanks Frederik for the great idea of integrating bookmark.el to
planner. The good thing is I only need to take care of the URL
handling, and bookmark.el will take care of the rest :)

Attached is the code. Note this is my second lisp (see, I'm growing :))
so welcome and comments :)

======================================================================
;;; planner-bookmark.el --- bookmark URL support for the Emacs planner
;;

;; Keywords: emacs planner bookmark remember note
;; Author: Dryice Liu <dryice AT liu DOT com DOT cn>
;; Description: use bookmark.el in Emacs planner

;; This file is not part of GNU Emacs.

;; Copyright (C) 2004 Dryice Dong Liu . All rights reserved.

;; This is free software; you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation; either version 2, or (at your option) any later
;; version.
;;
;; This is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
;; for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
;; MA 02111-1307, USA.

;;; Commentary:
;;
;; Place planner-bookmark.el in your load path and add this to your .emacs:
;;
;;    (require 'planner-bookmark)
;;
;; Annotations will be of the form
;; [[bookmark://bookmark-name][bookmark-description]]
;; bookmark-description will use bookmark-annotation if available,
;; else bookmark-name will be used.
;;
;; Note this file advice `bookmark-set'. If you don't want to take a
;; note everytime you set a bookmark, set
;; `planner-bookmark-take-note-after-set-bookmark-flag' to nil

;;; CODE

(require 'planner)
(require 'bookmark)
(require 'remember)

;;; User variables

(defgroup planner-bookmark nil
  "Bookmark URL support for planner.el."
  :prefix "planner-timeclock-summary"
  :group 'planner)

(defcustom planner-bookmark-take-note-after-set-bookmark-flag
  t
  "Non-nil means popup a remember buffer to take note after set a new bookmark."
  :type 'boolean
  :group 'planner-bookmark)

;;;; User variables stop here

(defadvice bookmark-set (after planner-bookmark activate)
  "set a bookmark, and take a note of it if
`planner-bookmark-take-note-after-set-bookmark-flag' is set."
  (if planner-bookmark-take-note-after-set-bookmark-flag
      ;; bookmark can take us where we want. we don't need two URLs
      (let ((remember-annotation-functions nil))
	(remember (concat "\n\n" (planner-bookmark-make-url
				  bookmark-current-bookmark))))))

;;;###autoload
(defun planner-bookmark-annotation-from-bookmark ()
  "If called from a bookmark buffer, return an annotation.
Suitable for use in `planner-annotation-functions'."
  (if (and (eq major-mode 'bookmark-bmenu-mode)
	   (bookmark-bmenu-check-position))
      (planner-bookmark-make-url (bookmark-bmenu-bookmark))))

(defun planner-bookmark-make-url (bookmark-name)
  "make the bookmark URL by given bookmark-name."
  (let (bookmark-annotation)
    (setq bookmark-annotation (bookmark-get-annotation
			       bookmark-name))
    (if (and bookmark-annotation (string-equal bookmark-annotation ""))
	(setq bookmark-annotation nil))
    (concat "[[bookmark://" bookmark-name "][" 
	    (if bookmark-annotation
		bookmark-annotation
	      bookmark-name)
	    "]]")))

;;;###autoload
(defun planner-bookmark-browse-url (url)
  "If this is a bookmark URL, jump to it."
  (when (string-match "^bookmark:/?/?\\(.+\\)" url)
    (bookmark-jump (match-string 1 url))
    t))

;;;###autoload
(defun planner-bookmark-resolve-url (id)
  "bookmark URL doesn't mean much when publishing, so just return nil."
          nil)

(planner-add-protocol "bookmark" 'planner-bookmark-browse-url 'planner-bookmark-resolve-url)
(add-hook 'planner-annotation-functions 'planner-bookmark-annotation-from-bookmark)
(custom-add-option 'planner-annotation-functions 'planner-bookmark-annotation-from-bookmark)

(provide 'planner-bookmark)
======================================================================

Hmmm, there's a good chance that there's space in the bookmark
name. So I should use planner-make-link instead make the link myself:

======================================================================
--- planner-bookmark.el.orig	Thu Dec 16 22:10:45 2004
+++ planner-bookmark.el	Thu Dec 16 22:07:48 2004
@@ -84,11 +84,11 @@
 			       bookmark-name))
     (if (and bookmark-annotation (string-equal bookmark-annotation ""))
 	(setq bookmark-annotation nil))
-    (concat "[[bookmark://" bookmark-name "][" 
-	    (if bookmark-annotation
-		bookmark-annotation
-	      bookmark-name)
-	    "]]")))
+    (planner-make-link
+     (concat "bookmark://" bookmark-name)
+     (if bookmark-annotation
+	 bookmark-annotation
+       bookmark-name))))
 
 ;;;###autoload
 (defun planner-bookmark-browse-url (url)
======================================================================

To start a journal copy journal.el to your load path and add the
following to your ~/.emacs:

  (require 'journal)

To view the journal home page just type M-x journal.  To create
entries, type M-x journal-create-entry.  Enter the title you wish to
use for this entry.  Then type the categories you wish the entry to
belong to.  Just typing "Emacs" will add the entry to "CategoryEmacs",
you may type the full name if you wish.  Type RET to end the list of
categories.

Now type the contents of your entry.  When you are done, save the
buffer.  You will notice that the contents will have been
automatically copied to each of the category pages, the day page, and
the home page.

You may edit the contents of any entry from anywhere.  Whenever a
journal buffer is saved, the contents will be updated everywhere
throughout the journal.

In the near future, remember, planner and RSS integration will be
added.  journal.el was written in a way that makes this easy.
Features such as publishing to Livejournal, Blogger, Advogato,
etc. are planned.

To keep up with the latest versions, download Gnu Arch and just type:

  tla register-archive hoan@ton-that.org--2005 \
                       http://www.ton-that.org/Arch/2005
  tla get hoan@ton-that.org--2005--journal--main--1.0

The documentation will be maintained on TheEmacsWiki at
http://www.emacswiki.org/cgi-bin/wiki/JournalMode.
==================
  Sacha> This sounds like something grep can do:

  Sacha>     grep -e '^#[ABC][0-9]* \+[^XC]' *

  Sacha> You can use grep to filter the list according to team members
  Sacha> as well.

When I saw this, all I could say was "Doh!"  I needed to do a bit more
"out of the box" thinking.  Grep wasn't quite up to what I wanted, but
gawk was.  If anyone is interested, here is what I am using right now:

---  cut here ----
#!/usr/bin/awk -f

BEGIN {
  in_tasks = 0;
}

/^\#[A-C] +[_o>CD] +/ {
  if (in_tasks) {
    $0 = gensub(/\[\[([^\]]*)\]\[([^\]]*)\]\]/, "\\2", "g");
    $0 = gensub(/\([A-Za-z0-9-_./]*\)$/, "", "g");
    print;
  }
}

/^\* Tasks/ {
  in_tasks = 1;
  print;
}

/^\* / && ! /^* Tasks/ {
  in_tasks = 0;
}

/^\*\*+ / {
  print;
}
---  cut here ----

This extracts just the tasks section, replaces the emacs-wiki links
with just the titles, and eliminate the page references at the end.  I
like it.  At least, it does the job I want.  

==============

I could not find any relevant information about backlinks in the list archive,
so I'd like to ask everyone here for your opinion (I hope I didn't overlook
something obvious).

I'd like to have optional hierarchical backlinks in the files maintained by
EmacsWiki mode. In case this term is not self-explanatory: a backlink is a link
that points back to the page from where a new Wiki file was created (which, in
turn, contains a forward link to the new file). I'd like to know whether anyone
is interested in having this feature, and whether anyone feels capable to code
it (my Elisp is whacky at best).

I'd like to explain briefly why this feature would be useful to me. I use
EmacsWiki as the backend of planner.el. I organize the experiments and results
in my biochemical lab using this planning tool. As a matter of fact, the
resulting Wiki is pretty much structured in terms of project, sub-projects,
sub-sub-projects etc, and individual experiments containing the links to the
data and evaluation. Currently I insert the backlinks manually at the top of my
Wiki files. These backlinks allow me to traverse the structure backwards, that
is from the experiment back to the project.

The backlink is generated from the filename and the backlink of the "parent"
page. Let me give an example (I use the backlinks in boldface) for a Wiki with
the file 'ProJect' as root:

2nd level: **/ ProJect**
3rd level: **/ ProJect / ClinicalSamples**
4th level: **/ ProJect / ClinicalSamples / InCor**

and so on. As you can see, EmacsWiki mode will interpret the links individually,
so you can traverse back to any level in the structure. Code-wise, all you need
to do is to use the backlink of the originating page and add its filename to
obtain the new backlink of the child page.

An added benefit of these backlinks is that you can easily extract them to
display your Wiki e.g. as a mind map.

==============

Ok, here goes. Please find attached the latest patch against
emacs-wiki 2.66. Let me briefly explain the changes:

1) emacs-wiki.el:
- added a defcustom to toggle backlinks on or off (default is off). To
toggle them on, either use Customize or add the following to your
.emacs:

(setq emacs-wiki-create-backlinks t)

- emacs-wiki-visit-link: contains most of the code to add backlinks

- emacs-wiki-follow-name-at-mouse: buffers were not refreshed if links
  were visited by mouse, rather than by keyboard. This is fixed here.

2) emacs-wiki-regexps.el
- added a defcustom for a regexp to exclude certain files from
receiving backlinks. The default is to exclude planner day files.

I use the backlinks from planner-mode, and they appear to work ok
except in a few bordercases. Backlinks are not inserted into existing
files. However, all I can rely on is the file-alist. This does not
contain newly created buffers that were not saved yet. A safe way to
screw up things is to start from scratch with a new file in your
otherwise empty planner directory, create a new file by means of a
Wiki link, and use the newly created backlink to jump right back to
the original page, without saving anything inbetween. This way, the
original page will erroneously receive a second-level backlink. To
make things more manageable, my patch forces newly created files (by
means of following a Wiki link) to be saved right away. This minimizes
the problem, but might not be acceptable for everyone.

If you want to see what backlinks are good for without actually
patching your emacs-wiki, please visit:

http://www.mhoenicka.de/software/hacks/plans/ProJect.html

This is a fake plan that you can navigate by means of the Wiki links
and the backlinks close to the top of each page (ProJect.html doesn't
have a backlink as it is the top-level page).

To get an overview, please visit

http://www.mhoenicka.de/software/hacks/plans/tasklist.html

This page was created by the scripts tasklist.pl and taskmm.pl,
described in more detail in:

http://www.mhoenicka.de/software/hacks.html

The task overview works just fine with the unpatched version of
emacs-wiki. The mind map at the bottom of the page relies on the
backlink feature, though. The mind map (Java 1.4 or later plugin
required, and a little patience to load the applet) gives a nice
overview over your plans. The nodes are collapsible (click on the
right-hand side of the node) and act as hyperlinks (click on the
left-hand side) to the planner HTML pages. The symbols and the node
color describe the task status in this node.

I'd be interested to know whether the backlink patch interferes in any
way with how other people use emacs-wiki. If it works ok for others,
I'd be more than happy to donate the code.

regards,
 Markus

[2. emacs-wiki backlink patch --- application/octet-stream; emacs-wiki-backlink.patch]...


==============

I was using planner to make a hierarchical list of tasks for a project
and got sick of hitting C-u C-c C-t and then moving the task into the
correct position from the top of the page.  So, here's a patch that
adds a C-c C-S-t binding that inserts the new task wherever you have
the cursor if you're on a plan page.

As an example, I was structuring my plan page like so:

--8<---------------cut here---------------start------------->8---
* Tasks

** Major group of tasks

#B   _ Task

*** Less major group

#B   _ Task

*** Another subgroup

#B   _ Task
#B   _ Task

** Group 2

*** Subgroup three

#B   _ Task
--8<---------------cut here---------------end--------------->8---

Regards,
Toby.

--- emacs-lisp/sacha-dev/planner/planner.el~	2004-12-27 18:27:33.000000000 +1300
+++ emacs-lisp/sacha-dev/planner/planner.el	2005-01-05 10:15:33.647408300 +1300
@@ -658,6 +658,7 @@
       (define-key map "\C-c\C-j\C-r" 'planner-goto-most-recent)) ; recent
 
     (define-key map "\C-c\C-t" 'planner-create-task-from-buffer)
+    (define-key map '[(control ?c) (control ?T)] 'planner-create-task-from-buffer-at-point)
     (define-key map "\C-c\C-c" 'planner-copy-or-move-task)
     (define-key map "\C-c\C-u" 'planner-raise-task)
     (define-key map "\C-c\C-d" 'planner-lower-task)
@@ -1537,6 +1538,13 @@
 
 ;;;_   + Creation
 
+(defvar planner-insert-task-at-point-flag nil
+  "Whether to insert the current task at point in the plan page.
+The usual behaviour is to insert it in the first block of tasks
+in the 'Tasks' section of the plan page.  This is dynamically
+bound to `t' by the `planner-create-task-from-buffer-at-point'
+function.")
+
 (defun planner-create-task-from-info
   (info &optional category priority status description link-text date plan)
   "Create a task in the date and plan pages based on INFO.
@@ -1557,8 +1565,15 @@
                             plan-page)
               (setq plan-page nil)))
         (when (and plan-page (not (string= plan-page "")))
-          (planner-find-file plan-page)
-          (planner-seek-task-creation-point)
+          ;; If the user has requested that the task be inserted at
+          ;; point and the current buffer is the correct plan page for
+          ;; the task then don't move point and therefore insert the
+          ;; task where the user wanted.  Otherwise, go to the normal
+          ;; place for inserting tasks.
+          (unless (and planner-insert-task-at-point-flag
+                       (string= (planner-page-name) plan-page))
+            (planner-find-file plan-page)
+            (planner-seek-task-creation-point))
           (insert (planner-format-task info category priority
                                        status description
                                        date-page date-page)
@@ -2803,7 +2818,8 @@
                (or planner-expand-name-favor-future-p
                    planner-task-dates-favor-future-p)))
           (planner-read-date))))
-    (if (and current-prefix-arg (planner-derived-mode-p 'planner-mode)
+    (if (and (or current-prefix-arg planner-insert-task-at-point-flag)
+             (planner-derived-mode-p 'planner-mode)
              (not (string-match planner-date-regexp (planner-page-name))))
         ;; Universal prefix means pick up from current page
         (planner-page-name)
@@ -2827,6 +2843,15 @@
                        plan-page
                        status))
 
+(defun planner-create-task-from-buffer-at-point ()
+  "Create a new task at the current point position in a plan page.
+The task created is exactly the same as would be created by
+`planner-create-task-from-buffer' with a prefix argument.  This
+is only useful when editing a plan page."
+  (interactive)
+  (let ((planner-insert-task-at-point-flag t))
+    (call-interactively 'planner-create-task-from-buffer)))
+
 (defun planner-create-task (title date &optional annotation plan-page status)
   "Create a new task named TITLE based on the current Wiki page.
 If DATE is non-nil, makes a daily entry on DATE, else makes an

==============


Emacs-wiki supports these sort of double bracket links.  The format is
[[link][description]].  The description may be omitted.  If the link
is an image, it is inlined.  The included texinfo manual might be of
further assistance.

If you really don't want wiki words to be highlighted or interpreted,
you could put something like the following in your configuration file.

  (setq emacs-wiki-name-regexp "!!!!!")

It's a bit of a rough hack, but what it does is only treat the "!!!!!"
string as a WikiWord.  Since this is highly unlikely to occur in real
life, the effect is to disable WikiWords.

 ==============


  This is usually "c:/" but I would examine (getenv "HOME") to make
  sure.  I usually set up a "~/emacs/lisp" directory for all of my lisp files.
  This is largely a matter of convention.  After you decide where to put
  your files, if the directory is not in load-path, then you need to put
  add it to the list of paths that emacs looks for files.  For example:
  
  (add-to-list 'load-path "~/emacs/lisp 'append)
==============

> 			How can we search in the Wiki?

`emacs-wiki-grep'

> 			Can also several directory structures be used
> with the WikiMode

Yes.  You'll probably want to read the `Multiple Projects' section of
the manual if you want to separate your directories into "Projects".
Multiple directories can belong to one project.

==============

>
>> I've taken to keeping track of my appointments as tasks. It's easier
>> for me to create a task from a buffer than it is to open my diary file
>> and add an entry. I can also mark them in progress.
>
> Interesting. I've been thinking about the best solution for this
> also. Can you point me to an example on your online blog?

 There are also my diary add-ons that allow me to hit C-x C-d in a
buffer and get planner-style prompts and annotations.  i.e.

12/1/2005 08:00 write back [[gnus://nntp+news.gmane.org:gmane.emacs.wiki.general/<u6522tzdd.fsf@edendevelopment.co.uk>][Post from Chris Parsons on gmane.emacs.wiki.general]] 

was created in the email buffer for this post.  C-x C-d and then a
planner style prompt for the date and an entry for time.  I never see
the diary file.  

http://www.emacswiki.org/cgi-bin/wiki/PlannerModeContrib under "Diary
annotation".  

There is no rescheduling.  But I prefer to keep tasks and appointments
separate, so this works well for me.

==============


I have decided to move emacs-wiki-journal.el and emacs-wiki-bloxsom.el
into their own separate package.  The reason for this is that since
there are now alternatives out there, like Journal by Hoan Ton-That,
it needs to be emphasized that these files are more of an add-on
package than a core package.

The new branch is called emacs-wiki-journal--main--1.0.

If you are using Arch to keep up-to-date, do the following.

  tla get -A mwolson@gnu.org--2005 emacs-wiki-journal--main--1.0 \
      emacs-wiki-journal

Then add this path to `load-path'.

If you prefer downloading a tarball, the latest one is available at
http://www.mwolson.org/static/dist/emacs-wiki-journal-latest.tar.gz.

`emacs-wiki-bloxsom.el' is now called `bloxsom.el' since that is the
naming scheme that the source code uses internally.

For your convenience, I have attached the ChangeLog for the changes
that have happened since the split.

==============


First of all, thanks to Sacha for maintaining this wonderful piece of
software. Once I got used to it I couldn't imagine how to get
organized without it.

Here's a short description of how I (ab)use planner. I'm running a
biomedical lab, and I've figured out a way to use planner to schedule
my experiments and to abuse it as a kind of electronic lab
journal. Each of my research projects has its own planner page. Each
project is subdivided into subprojects and sub-subprojects, with as
many levels as required. The "leafs" of this structure are individual
experiments. These are special planner pages that basically contain a
description of the experiment, the required resources, the schedule
and so on - and of course the tasks that should be performed. I
publish these pages as HTML and hand them out to my technicians. They
like to abuse the printed sheets to write down experimental details
which they later transfer into their (still dead-tree) lab
journals. Once the experiment is finished, I add a brief description of
the results and links to the electronic data to the planner page,
publish it again, and attach the sheet to a printout of the evaluated
results (graphs, tables, whatever). As each experiment gets an unique
name (usually based on the day and one or two keywords describing the
experiment), it is easy to return from the printout to the electronic
version if necessary.

A big plus is that the data are accessible to the standard Unix tools
to unearth information. E.g. this week I had to find out on which date
we first ran an experiment using bovine veins. In a dead-tree lab
journal you'd have to browse for an age and a half, but with planner
it is a matter of a single grep command. Way cool.

As the projects, subprojects, subsubprojects... and experiments are
strictly hierarchical, I soon started to add hierarchical backlinks to
my planner pages in order to simplify navigation within a
project. Eventually I came up with a patch for emacs-wiki.el which
inserts these backlinks automatically (I've announced this on this
list but it didn't stir up too much attention). Additionally, I wanted
to have an overview over my planned tasks that allows me to see a week
or a month of work in a glimpse. I developed a Perl script which
extracts the information from planner day pages and creates a HTML
tasklist. For me this is the most heavily used interface to planner
today.

To make matters even more convenient, I also came up with a Perl
script which uses the backlinks in my planner pages to create an XML
mind map viewable with FreeMind. This turned out to be extremely
valuable, as you can see an overview over all your projects, but you
can also unfold each subproject until you see all individual
experiments. Needless to say, the nodes in the mind map are clickable
and open the corresponding planner page in a web browser.

In case anyone is interested in this add-on stuff, please check out:

http://www.mhoenicka.de/software/hacks.html

I understand that this kind of use is probably pretty close to the
edge of what planner was designed for. However, it is the flexibility
and simplicity of the data which allow everyone to use or abuse
planner the way she needs to. I'd be a lot more confused than I am
anyway without planner.

==============


Most patches can be installed by downloading the patch, changing into
the directory that you want to change, and typing

$ cat /location/of/the.patch | patch -p1

This will modify the files in the current directory.

==============


You can save the entire message and pass it to the patch command
while in the directory of the appropriate file. For example, grab a
planner patch and

cd planner
patch -p0 < somefile.patch

It'll modify the .el files. =)
==============


You have already got two good answers, so I just want to point out
that this can be done in Emacs:  read the header of the patch to see
what file it modifies, and then type M-x ediff-patch-file.  Tell Ediff
that the patch is already in a buffer, namely the article buffer, and
then enter the file within your planner source directory to patch.
Afterwards, reload the patched file with M-x eval-buffer.

Ediff can be confusing sometimes, so use whatever method suits you.

==============


Well, I figured out the answer to my second question, "Why doesn't
(planner-diary-entries-here) include the date string and the line
following?"

In planner-diary.el, there are two lines of code that move point past
the line of equal signs, effectively skipping the first two lines of the
diary entry.

Here's my "fix" for that, which merely comments out the statements, but
includes two closing parens on the next line:

                 (if (> no-of-days 1)   ; if more than 1 day, show
everything
                     (progn
                       (while (re-search-forward "^=+$" nil t)
                         (replace-match
                          (make-string (length (match-string 0)) ?-)))
                       (point-min))
                   ;; remove date and lots of =s if just for 1 day
                   (progn (goto-char (point-min))
; 02/04/05 RZ Commented out the next two statements so that date will be
included.
;                          (search-forward-regexp "^=+$") ; one or more
=
;                          (1+ (point))
		    ))
                 ;; remove final newline

A more elegant solution would introduce and test a Boolean variable that
the user can set to control whether the date string and subsequent line
of equal signs gets included in the day page.  Perhaps
`planner-diary-include-date-string-in-day-page' might be a good choice?

==============


Take a look at the commentary in planner-diary.el...

I have in my .emacs:
(add-hook 'diary-display-hook 'fancy-diary-display)


(require 'planner-diary)
(setq planner-diary-use-diary t)
(planner-insinuate-diary)
(setq planner-diary-number-of-days 7)
(setq planner-diary-file diary-file)

which gives the entries for the next 7 days.  You could try and up
this to 90, I suppose...

Note that planner-diary.el has a typo in the commentary...

-;; `planner-diary-number-of-diary-entries' accordingly.  This works for
+;; `planner-diary-number-of-days' accordingly.  This works for

==============


This is not exactly what you want, but may help :)

By planner-trunk.el, you group the tasks according to a list of
regexps. You may want to use it after carring tasks over.

The file attached. And is also on patch-18 of

Location: http://dryice.3322.org/arch/
Archive name: dryice@liu.com.cn--2005
Branch: planner--dev--1.0

-- 
Dryice @ http://dryice.3322.org

Please avoid sending me Word or PowerPoint attachments.
See http://www.fsf.org/philosophy/sylvester-response.html
[2. application/emacs-lisp; planner-trunk.el]...
==============
Use planner-create-note-from-task - it'll add a little link to the task, plus a note
on the day page. 

Pass a prefix argument to get the note put on the task plan page instead
- I personally use:

(defun chrismdp/planner-create-note-from-task() (interactive) (planner-create-note-from-task 1))
(define-key planner-mode-map (kbd "C-c C-n") 'chrismdp/planner-create-note-from-task)

==============


A small function for automatically creating a note for a task, if point
is on that task.  A prefix argument puts the task on the project page
instead of the day page.

(defun hsh-planner-create-note-from-task-maybe (&optional plan-page-p)
  (interactive "P")
    (let ((case-fold-search nil)
          (planner-use-font-lock nil))
      (beginning-of-line)
      (if (re-search-forward "^#[A-C][0-9]*" nil t)
          (planner-create-note-from-task plan-page-p)
        (planner-create-note))))

==============


I've been working on a perl library that parses planner-mode pages,
for use with emacs planner-mode or eventually as a stand-alone
perl-based wiki plugin.

I have an early version of my library available that parses
planner-mode pages, stores data in a central SQLite database.  It also
exports tasks and schedule data to ICAL (a standardized calendaring
format) using the ICalLite perl module, which I began writing
specifically for that purpose.

  http://www.geekfarm.org/twiki/bin/view/Main/PlannerMode

So far, the only PlannerMode script that's fully working uses Sacha's
remind.el lisp code, along with my own plan2rem script that uses my
PlannerMode and ICalLite libraries to create an ICAL file.   By
keeping the ICAL file behind a WebDAV server, I can subscribe to it
and track any changes automatically in my ICAL client, the Mac OS X
calendar app (it's also supported by the mozilla calendar client and
others).  I can see all my incomplete tasks on the to-do list (with
proper due dates and such), along with a calendar view of my schedule.
The mac client even supports syncing both task lists and schedule data
to my palmtop. :)

The code is alpha quality.  It needs some refactoring, may have
numerous bugs, and the docs are pretty weak at the moment.  The
modules are available for download at the link above and the plan2rem
script (included in the PlannerMode tarball) seems to be working great
at this point, at least for me.  Suggestions for improvement are
welcomed.

==============

I'm assuming that you are using planner-diary.el?  

Did you try my diary-annotation functions?  
http://www.emacswiki.org/cgi-bin/wiki/PlannerModeContrib

You do not get to add the appointment to the plan page ("as is
natural") however you do get a planner-like way to make a diary entry
in the mini-buffer with the added bonus of planner-style links.  I
find this much more convenient than any scheme I could think of for
trying to edit the plan pages.

I have the following easy-to-remember keybindings:

C-x C-n remember
C-x C-t planner-create-task-from-buffer
C-x C-d planner-diary-add-entry

==============

I'm in a similar approach. I see diary items as "appointment" that I
have to do at a specific time and "* Schedule" items as "schedule"
which I can ignore (which I often do :)

> I think at some point Sacha has some (python?) code that read a
> "Schedule" section and put the results into a diary file.  You could
> maybe check that out and start from there?  Maybe someone else
> remembers it better than I do.

Do you mean planner-export-diary.el? Here's how I use it:

I overwrite the planner-export-diary-format-schedule-entries-for-diary
so items from "* Schedule" and "~/.diary" looks different in "* Diary"
and the appt reminder:
======================================================================
;; over write the one in planner-export-diary.el to distinguish the
;; original appointment and the schedule
(defun planner-export-diary-format-schedule-entries-for-diary (list)
  "Format LIST as diary entries.
LIST should contain entries of the form [DATE START END
DATA]."
  (mapconcat (lambda (item)
               (concat
                (let ((date (planner-filename-to-calendar-date (elt item 0))))
                  (format "%02d/%02d/%04d"
                          (elt date 0)
                          (elt date 1)
                          (elt date 2)))
                " "
                (elt item 1)
                "-"
                (elt item 2)
                " ~~~"
                (elt item 3)))
             list "\n"))
======================================================================

So say I have
,----
| 09:30 | 10:00 | check emacs wiki mail list
`----
in "* Schedule" and
,----
| Feb 21, 2005 10:00-11:00 a meeting!
`----
in my ~/.diary, I'll get
,----
| 09:30-10:00 ~~~check emacs wiki mail list
| 10:00-11:00 a meeting!
`----
in "* Diary". So when I see an appt reminder starting with "~~~", I
can safely ignore it :) It's kind of like Jim Ottaway's "@" magic but
I can decide if I want to ignore some thing on the fly :)

I also have ddliu-move-time to help me in the "* Schedule"
section:
======================================================================
(defun ddliu-move-time (BEG END offset)
  "Add offset minutes to all times in the form HH:MM in a
region. offset can be negative. I use this in the Schedule section of
planner day plan page"
  (interactive "r
nMove by minutes: ")
  (save-excursion
    (save-restriction
      (narrow-to-region BEG END)
      (goto-char (point-min))
      (while (search-forward-regexp
	      "\\([0-9]?[0-9]:[0-9][0-9]\\(am\\|pm\\)?\\)" nil t)
	(let ((time-string (match-string 1))
	      old-time new-time)
	  (save-match-data
	    (setq old-time (appt-convert-time time-string))
	    (setq new-time (+ old-time offset)))
	  (replace-match (ddliu-minutes-to-string new-time))))
      (widen))))
======================================================================

> I saw that in fact `planner-diary-add-entry' *is* defined in
> planner-diary.el, but the definition is commented out.  
> ...  

> Why?  I uncommented the the commented out region (the region that's
> commented out only once), loaded the function definition, and it
> seemed to work just fine.  Is there some subtle bug that I should be
> aware of?

I don't think so.  As the note above it says, whoever maintains
planner-diary.el would like it to write to a particular diary file
instead of the default.  

The following seems to work, where the diary entry gets added to
"planner-diary-file".  This is the file that planner-diary reads to
create the diary display.  I *suppose* that someone may want to make
the writeable and So sorry, I cut myself off...

Anyways here is the code for Sacha's approval:

(defun planner-diary-add-entry (date time text)
  "Prompt for a diary entry to add to `diary-file'.  Will run
  planner-annotations to make hyper links"
  (interactive (list (planner-read-date)
		     (read-string "Time: ")
                     (read-string "Diary entry: ")))
  (save-excursion
    (save-window-excursion
      (make-diary-entry
       (concat
        (let ((cal-date (planner-filename-to-calendar-date date)))
	  (calendar-date-string cal-date t t))
	  " " time " " text " "
        (run-hook-with-args-until-success
         'planner-annotation-functions))
       nil planner-diary-file))))


==============

	M-x customize-variable RET emacs-wiki-style-sheet RET

or add something like this to your .emacs file:

	(setq emacs-wiki-style-sheet "
	  <link rel=\"stylesheet alternate\"
	        title=\"White on Black\" href=\"/share/core-dark.css\"
	        type=\"text/css\" media=\"screen\" />
	  <link rel=\"stylesheet\"
	        title=\"Black on White\" href=\"/share/core-light.css\"
	        type=\"text/css\" media=\"screen\" />
	  <link rel=\"stylesheet\"
	        title=\"Black on White\" href=\"/share/core-light.css\"
	        type=\"text/css\" media=\"print\" />")

You can find my style sheets here:
	http://twb.ath.cx/share/core-light.css
	http://twb.ath.cx/share/core-dark.css

Remember to reload your customization (e.g. by quitting emacs and
starting it again) and republishing (e.g. by touching all the source
files, then running emacs-wiki-publish).

==============


I have been tinkering with some other aspects of diary and calendar
usage: in particular, how to have nice fontification of the calendar
that distinguishes between cyclical tasks, appointments, and ordinary
tasks, and how more efficiently to extract cyclical information from
diary files.

What I have here[1] is a peculiar mixture of some parts of
planner-appt, some parts of planner-cyclic, and some new bits.

Together with planner-appt, tt does most of the diary things in
planner in ways that I am mostly happy with. 

I have called it jeho-diary.el because it is probably very peculiar
[to me], but there might be one or two things in it of broader
interest. There is a bit of commentary in the source.

Regards,

Jim Ottaway

Footnotes: 
[1]  

http://www.users.zetnet.co.uk/jeho/jeho-diary.el

Or, in the arch repository:

Location: http://www.users.zetnet.co.uk/jeho/archives/2005
Archive name: jeho@jeho.org--2005
Branch: planner--jeho--1.0
Patch: 45

==============

Here is a brief list of the available link forms provided by various
planner packages. I couldn't find them listed in this form
elsewhere. Please add any that I have missed

emacs-wiki links
[[link text][optional link description]]

planner-bbdb
[[bbdb://Sacha.*Chua][Sacha]] will be linked to the blog, web
or net fields of the first matching BBDB record.

planner-bookmark
[[bookmark://bookmark-name][bookmark-description]]
bookmark-description will use bookmark-annotation if available,
else bookmark-name will be used.

planner-erc
Annotations will be of the form
[[erc://server/nick/#channel][Chat with nick on server#channel]]
[[erc://server/nick][Chat with nick on server]]
[[erc://server][Chat on server]]

planner-lisp
[[lisp://plan][Plan]] will be rendered as
"Plan". Selecting the link will run the plan function interactively.

planner-rmail
Annotations will be of the form
[[rmail://PATH/TO/INBOX/<E1AyTpt-0000JR-LU@sacha.ateneo.edu>][E-mail
from Sacha Chua]]

planner-unix-mail
Annotations will be of the form
[[mail://PATH/TO/INBOX/E1AyTpt-0000JR-LU%40sacha.ateneo.edu][E-mail
from Sacha Chua]]

planner-vm
Annotations will be of the form
[[vm://home/test/INBOX/<E1AyTpt-0000JR-LU@sacha.ateneo.edu>][E-mail
from Sacha Chua]]

planner-xtla
[[xtla://miles@gnu.org--gnu-2005/emacs--cvs-trunk--0--patch-19][patch-19]]
can be browsed easily via xtla

==============

Thanks for pointing me to planner-trunk.  Two quick questions:

1. I customized the regex list and when I call planner-trunk-tasks I
   get the desired organization.  Where do put a call to
   planner-trunk-tasks so that it gets called when I visit plan pages?
   Or is something one just calls every now and again to clean up plan
   pages?

2. I thought I remembered some info in a recent post about
   planner-trunk and one of the outline modes so that, for exammple,
   one could hide/collapse the completed tasks section.  If anyone can
   eithr point me to the post or remind me, that would be great.
Nevermind.  Realized it was already doing this, I just needed to
switch on outline-minor-mode.

==============

That being said, you can run planner-edit-task-description to make
your changes, or use planner-id.el to have it happen automatically on
save.  The latter works for me.

I like planner-id.  People don't like the visual cruft of
{{Task:167}}, however, I just set the face colour to the background
colour, and the cruft goes away.  Well, except the blank space, but
that could be worse.  I guess I should try Sacha's icon.  Hmmmm, where
is that anyways?

==============

I figured out how to keep long extended links like [[link][text]] from
being broken up when you execute fill.  If you want to use this with
emacs-wiki, just replace all uses of "muse" with "emacs-wiki".  The
following code also prevents flyspell from trying to highlight text in
links.

(defun my-muse-mode-affect-p ()
  "Indicate whether this text should be messed with.
If nil is returned, it means that we should not fill here or
spell-check here.  If non-nil, it is safe to do both of these
things."
  (save-excursion
    (save-match-data
      (null (and (re-search-backward "\\[\\[\\|\\]\\]"
                                     (line-beginning-position) t)
                 (string= (or (match-string 0) "")
                          "[["))))))

;; Make flyspell not mess with links
(put 'muse-mode
     'flyspell-mode-predicate
     'my-muse-mode-affect-p)

;; Make fill not split up links
(eval-after-load "fill"
  (add-to-list 'fill-nobreak-predicate
               (lambda nil (null (my-muse-mode-affect-p)))))

I think I might include the fill-nobreak part of it (but not the
flyspell part) in future versions of emacs-wiki and Muse.  Would that
be OK with everyone?

==============

> I wrote a little elisp function (almost my first!) to replace a selected 
> name in my planner page with the appropriate bbdb:// link. It works, but 
> I am sure it is a terrible elisp style. Any suggestions on how to 
> improve it ? I hope to learn some good elisp style from you !

Hmmm... Hey, this looks familiar!

For an interactive way to do this (no messing with regions or whatnot),
download my http://sacha.free.net.ph/notebook/emacs/hippie-config.el ,
evaluate it, and set your hippie-expand-try-functions-list to
something like:

(setq hippie-expand-try-functions-list
      '(sacha/try-expand-planner-bbdb-annotation
        sacha/try-expand-planner-name
        try-expand-dabbrev
        try-complete-file-name
        try-expand-dabbrev-all-buffers))

Then type part of someone's name and use M-x hippie-expand to cycle
through possible completions. Bind M-x hippie-expand to something
convenient if you like it. I have it bound to F12.

You also get wiki name expansion, absolutely free!

But wait! There's more! If you type in a date specifier like "+1",
"today", or even "+tue" for next Tuesday, hippie-expand will let you
instantly replace it with a date link! Isn't that so cool?

Get http://sacha.free.net.ph/notebook/emacs/hippie-config.el now!

</infomercial mode>
==============


You will need

- Ulf Jasper's icalendar.el (http://de.geocities.com/ulf_jasper/emacs.html)
- phpicalendar on a webserver for publishing
(http://sourceforge.net/projects/phpicalendar/)
- (optional) sitecopy for automatically pushing files via ftp to a
webserver (http://www.lyra.org/sitecopy/)

Firstly add this to the end of your emacs diary

<example>
    # Local Variables:
    # after-save-hook: (crl/diary-export)
    # End:
</example>

This causes the function crl/diary-export to be called on save (as
there is, as far as I know, no diary-after-save-hook). Thanks to Ulf
Jasper for this tip.

Then something like this should be added to your .emacs :

<example>
(defun crl/diary-export ()
   (save-excursion
     (set-buffer (find-file-noselect "~/calendar/diary.ics" t))
     (erase-buffer)
     (icalendar-export-file "~/diary" "~/calendar/diary.ics")
     (when desktop-p
       (shell-command "/usr/local/bin/sitecopy --update diary")
       )
     )
   )
</example>

This snippet publishes the diary to the folder ~/calendar/diary.ics as
an icalendar file, and uses sitecopy to push the file to the
webserver. At the moment the save-excursion doesn't seem to work on my
emacs. Any suggestions appreciated !

On the server, or your local machine if you have apache/php
etc. installed, use phpicalendar to publish the icalendar file as a
webpage. This also generates an RSS feed. You will need to set up
sitecopy (or scp for example) to put the diary.ics file in the
phpicalendar "calendars" directory.

You end up with something that looks like this (check out the link to
RSS feeds) : http://acm.cs.uic.edu/calendar/ical/month.php

==============


> I follow the instructions for this, putting (setq planner-use-diary t) and
> (planner-diary-insinuate) in my .emacs. These don't seem to do anything. If I

Do you mean (setq planner-diary-use-diary t) ? Hope that helps!

==============


Well, a year back I shamelessly stole the PHP + planner
configurations of Sacha Chua to have some nice features such as a
autogenerated calendar and such. Recently I decided to do some
changes to it, to improve it. Herewith I've included the new
code. Please have a look at it, and comment/improve it. :) All
this code is working fine on my site http://joe.bsdnerds.org/ :)

Sorry., this is going to be a looong mail.

Note: you can use the Calendar.php unmodified. And, I'm no
PHP/Elisp programmer, so there is a very good possibility that
I'm doing some big mistakes in the code. So, please use it with
caution. :)

1. File: planner-include.php: This new version does not provide
   support for the today.php or the previous-day, next-day
   links. May be there should be some way of generating this from
   elisp. I'll have to look into it later. However, when there are
   a lot of day-pages, Sacha Chua's original code would overload
   the server by loading the entire file list into an array. Well,
   I guess that was the only way to get a arranged list. Other
   ways are way too complicated. This new code does not do that.,
   so it kinda server friendly :)

<?
$page = "";

/* pad zeros infront of a given string to $n len */
function pad($s, $n)
{
  $r = $s;
  while (strlen($r) < $n)
    {
      $r = "0".$r;
    }
  return $r;
}

function get_day_page($day, $month, $year)
{
  return pad($year, 4) . "." . pad($month, 2) . "." . pad($day, 2) . ".php";
}

class PlannerCalendar extends Calendar
{
    
  function getDateLink($day, $month, $year)
  {
    $dir = get_day_page($day, $month, $year);
    if (file_exists($dir))
      {
	return $dir;
      }
    else
      {
	return "";
      }
  }

  function getCalendarLink($month, $year)
  {
    return pad($year, 4) . "." . pad($month, 2) . ".php";
  }
}

$cal = new PlannerCalendar;
?>

2. File: header.php: This file should made as the emacs-wiki
   header file. i.e. should make emacs-wiki include this file as a
   header in every file it publishes. Please look into the
   code. It is fairly simple. Just some embedded elisp code. I've
   made elisp do most of the junk that originally PHP was trying
   to do.

<?
$msg = "";
$myaddress = "joe_steeve@gmx.net";

require_once "src/calendar.php";
require_once "src/planner-include.php";

$page = "<lisp>(emacs-wiki-page-name)</lisp>.php";

$curr_day = "<lisp>
   (if (string-match planner-date-regexp (emacs-wiki-page-name))
       (substring (emacs-wiki-page-name) 8 10)
    "")</lisp>";
$curr_month = "<lisp>
   (if (string-match joe-month-year-regexp (emacs-wiki-page-name))
       (substring (emacs-wiki-page-name) 5 7)
    "")</lisp>";
$curr_year = "<lisp>
   (if (string-match joe-month-year-regexp (emacs-wiki-page-name))
       (substring (emacs-wiki-page-name) 0 4)
    "")</lisp>";
?>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <title>Joe's homepage :: <lisp>(emacs-wiki-page-title)</lisp></title>
    <meta name="generator" content="emacs-wiki.el">
    <meta http-equiv="<lisp>emacs-wiki-meta-http-equiv</lisp>"
	  content="<lisp>emacs-wiki-meta-content</lisp>">
    <link rev="made" href="<lisp>emacs-wiki-maintainer</lisp>">
    <link rel="home" href="<lisp>(emacs-wiki-published-name
				     emacs-wiki-home-page)</lisp>">
    <link rel="index" href="<lisp>(emacs-wiki-published-name
				      emacs-wiki-index-page)</lisp>">
    <link rel="stylesheet" type="text/css" href="<lisp>emacs-wiki-style-sheet</lisp>">
  </head>
  <body>
  <div id="sidebar">
<?
if ($curr_month && $curr_year)
{
  print $cal->getMonthView($curr_month, $curr_year);
}
else
{
  print $cal->getCurrentMonthView();  
}
?>

</div>
   <div id="banner">
     <h1>Joe Steeve :: <lisp>(emacs-wiki-page-title)</lisp></h1>
     <div id="banner_links">
       <a href="index.php">Home</a> |
       <a href="cgi-bin/blosxom.cgi">Articles</a> <a href="cgi-bin/blosxom.cgi/index.rss"><img border="0" src="images/xml.png" alt="XML"></a> |
       <a href="RecentPosts.php">Journal</a> <a href="journal.rdf"><img border="0" src="images/xml.png" alt="XML"></a> |
       <a href="Bookmarks.php">Bookmarks</a>
     </div><!--banner_links-->
   </div><!--banner-->
   <div id="content">
      <!-- Page published by Emacs Wiki begins here -->

3. File: footer.php : And here is the footer.php which should be
   included as a footer by emacs-lisp.

<html><head><!-- Page published by Emacs Wiki ends here --></head>
<hr size="1">
<table width=100%>
<tr><td=50%>
Updated:  <lisp>(format-time-string emacs-wiki-footer-date-format (nth 5 (file-attributes buffer-file-name)))</lisp><br>
<a href="http://www.gnu.org/software/emacs/"><img src="images/emacs.png" alt="emacs"></a>
</td><td width=50% align="right">
<a href="WikiIndex.php">Index</a>
<a href="#top">Top</a>
</td></tr>
</table>
<hr size="1">

</div>
</body></html>

==============


It's mostly used for viewing your diary quickly from within a Planner
buffer.  The diary section doesn't publish well by default.

> In my schedule, I have planner-diary to put my entry for a few days,
> like
>
> Wednesday, June 8, 2005
> -----------------------
> 09:30-11:00 PPADNI (T) FA3 (LeicIst)
> 15:00-15:40 Pool (LeicIst)
>
> but this ends up with an horrible html formatting, withouth linebreaks, etc,
> etc. Could anyone point me to some info on this matter?

Try adding something like the following to your planner settings file
(.emacs or whatever).

(defun planner-diary-insert-diary (&optional force)
  "Insert the fancy diary for the day into the day plan file.
If FORCE is non-nil, insert a diary section even if there is no
`planner-diary-string' in the buffer."
  (interactive "P")
  ;; sanity check
  (let ((date (planner-diary-get-name)))
    (unless (string-match planner-date-regexp date)
      (error "Cannot insert diary in this buffer"))
    (planner-diary-update-section
     date ; file
     planner-diary-string ; title
     (concat "<example>\n" (planner-diary-get-diary-entries     ; text
      (planner-filename-to-calendar-date  ; date
       date)
      planner-diary-number-of-days
      planner-diary-file)
       "\n</example>")
     force)))

This is nearly the same as the version of `planner-diary-insert-diary'
that is found in planner-diary.el, with the exception that it
surrounds the diary text with "<example>" and "</example>".  This
should cause the newlines to be preserved during publishing and make
the columns line up.

Hopefully this helps; I haven't tested it myself.

==============


I didn't have a chance to test all the modules yet, but from a quick
tour, planner-id and planner-gnus are absolutely indispensable,
planner-appt is nice (though I had to hack it otherwise it added
duplicate entries to the Emacs appt list on each file save), and
planner-trunk is handy.  I'd like to get started with planner-multi but
when I enable it, it wikifies page names twice (like
[[%5D%5DFoo%5D%5D]]), I'll have to dig a bit to understand what's going
on.

So far, Planner is indeed surprisingly similar to Gnus: large, scary,
inhumanly tweakable and immoderately powerful.  I love it!  :-)

==============

> This works well now is there a way to force it to open certain kinds
> of files in emacs instead of launching them? For instance when i
> link to a Perl script (some file.pl) when i tab to it and hit enter
> it launches the program in a command window rather then opening it
> for editing.

One way to easily pick up a hyperlink is to open the file in question
and do M-x planner-annotation-as-kill . (Note that this gets the
position URI now instead of just the filename. You can change this
behavior by customizing planner-annotation-functions and deleting the
-with-position part.)

When you figure out what the hyperlink should look like, then you can
usually figure out how to type other hyperlinks to similar resources.
For example, bbdb hyperlinks...

==============

> As far as I know, [[file://c:/path/to/file][file name]] within the
> task text should do
>the trick

==============


CAW> So I've come up with an idea... something like a "scratch page" that
CAW> is linked to a specific file, but really more for notes.  It should be
CAW> able to be called from the buffer you're working on by a simple key
CAW> sequence, possibly into another window (or frame, as the rest of the
CAW> world calls it).  Then, in the notes file, typing that key sequence
CAW> again should bring you right back to where you were working.

This is very similar to what I already do.  

1) Add saveplace to your .emacs file; any time you open a file, point
is at the last place you left it: (require 'saveplace)

2) I have a "notes" directory, and create a directory for any project
I'm working on.  I dump images, sometimes sections of emails, notes of
phone conversations, ideas, and scratch files into that directory.  I
keep the more formal working file elsewhere -- either in a
subdirectory of a "devel" directory, or a subdirectory of a "writing"
directory, depending on whether it's code (code-related design
documents also go in "devel") or writing.

If I'm working on a project and have something bit of cruft I need to
put someplace, I create a directory in notes. If it's a small project,
I can create a task with relevant link to my notes file (or
directory), or I might just drop a note in into a relevant planner
page, with links to the relevant files, and then create a task from
the note.

If it's a big project, it's SO easy to create its own planner
page. Just name it when you create a task, and there it goes.

3) Once a buffer is open in emacs, you can toggle back and forth
between the last two buffers used with "C-x b". If I've worked in a
third buffer since, C-x b Tab will bring up the list of open buffers;
or I can type  C-x b and then the initial letters of the buffer and
then tab -- and Emacs will complete the name as far as it can, and
then bring up a buffer of the matching open buffers; type the next
few characters, hit Tab, lather, rinse, repeat.  Your hand will
quickly learn what's unique for each buffer!

If I'm working in OpenOffice Writer, I just toggle back and forth
between the two windows -- most windowing systems have some keyboard
equivalent that lets you do that, often Alt-Tab (eg, Windows uses
this, and many other windowing systems do too).

CAW> It can be stored somewhat similar to the backup files that emacs
CAW> keeps.  In my situation, as with most sane emacs users, I have my
CAW> backup files saved to a special directory called "~/.backup".  The
CAW> same thing can probably be done with the notes files.

If you've saved a notes buffer to file once, it will be backed up
along with your other files.  (Personally, I have this C-x C-s twitch
in Emacs, and C-s twitch in any other app -- type end of important
thought/ unit/ sentence, hit C-x C-s) 

CAW> Does this make sense?

Yes, it's a great idea -- so much so that it's already implemented!

Never use the File menu or the Buffers menu; learn the keyboard
commands and command completion instead -- emacs is POWERFUL used this
way.

In fact, don't use the menus for anything you often do -- while
sometimes the menus provide handy organization, you can get at the
same organization by using M-` (that's a backtick) which is bound to
tmm-menubar -- this displays the menu contents in a buffer; play with
it.  

I just use the menus for things I don't use that much, or occasionally
for things that display better as a menu than in a buffer.

==============
 
> 
> > I'm making links by going ThisPageName#sectiona etc. Is there a way
> > this can be done without explicitly mentioning the pagename?
> 
> [[#sectiona]] seems to work over here. =) Hope that helps!

hehe, thanks, it does. I was just thrown off, since when you write
[[#thegoal][The Goal], the #thegoal bit is not highlited as link...
Wrong assumption on my part...

==============


I use ido mode, which is part of CVS GNU Emacs. ido is like iswitchb.
In fact, I use it almost exactly like I used iswitchb before, as I
turned off the file shortcuts of ido...

ido makes it so easy to manage the gazillions of buffers I have open.
I don't close buffers unless I have to. =)

> There are plenty of little tricks for buffer management. For irc, for

I bind certain keys to toggle between the current buffer and a useful
display. F7 toggles between whatever I'm looking at and a web browser,
and F9 etc. are my planner/remember shortcuts.

==============

OK, the emacs solution to this is two-fold.  If you know your buffer
name (and one often does, one works with a limited number of buffers,
and just know their names) hit C-x b and then type the first few
letters of the buffer name, then hit tab -- if Emacs isn't able to
hand you a unique buffer from that, hit tab again for a list of
possibilities, and type a few more characters; hit tab again, etc. 

If you don't remember the buffer name, hit C-x C-b for a window with a
list of all buffers; you can use that to manipulate those buffers, or
switch to them, or just to remind you of the buffer name.  

AH> I think maybe I just haven't learned the right tricks yet. Should I
AH> run each major app in separate frames? In separate instances? Is using
AH> an alernate Window Manager like RatPoison the answer?

I occasionally use two frames, especially if I want multiple windows
open in each frame, and am referring back and forth between them.  And
I sometimes run one emacs instance for gnus, and one for all my other
work -- but that's because gnus pigs the entire emacs instance any
time it does something.  

But mostly it's getting used to working with buffers, realizing that
you don't need the whole thing laid out across your screen as a visual
reference for each buffer, because it's so easy to bring up an index
into what's there (this is screen space that never fills up).  And
also, you'll be amazed at what you just know.

Get really slick at switching buffers and switching windows.  And learn
the help functions -- C-h a, C-h k, C-h f, C-h v 
Try C-h-f planner TAB
hit C-g
C-x b *Completions*

Now do the same thing with C-h-v planner TAB

Learn Info -- C-h i

If you want to keep the *Completions* window from getting overwritten
(or a *Help* window, etc) do M-x rename-uniquely
(aka M-x ren TAB u TAB)

(If you get "Command attempted to use minibuffer while in minibuffer",
it means you've got two commands going at once.  Use C-x o to cycle
through to the minibuffer window, hit C-g to kill the old command, and
keep going with what you were doing.)

==============

> I like to skim several notes on a single page.  It would be handy if I could
> just jump from one to the next (or previous) without lots of scrolling.
>
> I wonder whether there is a planner function that navigates from one note to
> the next (or previous) within a day page or project page?  C-h a planner.+note
> didn't reveal anything promising along these lines.
>
> Maybe someone has something like this tucked into his/her .emacs file?

I use allout-mode in all my planner buffers (I think other people do too). 

So, C-c C-n goes from one note to the next one. C-c C-p goes to the previous,
C-c C-h hides the note, C-c C-s shows it, etc. Very very handy.

==============


Have you considered "screen-sharing" packages, such as escreen?  I've
been using escreen for a couple weeks, and I really like it so far.  I
allocate a screen for gnus, another for erc, another for dired, and so
on.  Such a package involves just one emacs process.  Check out

http://www.emacswiki.org/cgi-bin/wiki/EmacsScreen

for more information.
 
===========


I have the same problem with emacs-wiki, as well as other more serious
Flyspell problems.  My workaround is to add the most frequently-occurring
CamelCase text to the dictionary.  This works because Flyspell "intercepts"
the click only when the text is miss-spelled.

=============


> *** Weekly planning
> The main reason I have a paper planner (8.5" x 11": weekly calendar +
> todo list + notes) is have that week-at-a-glance view. I like iCal's
> interface for planning tasks on a weekly basis, but I'm not entirely
> sure how to map that onto Emacs, and I like my daily notes and my
> day-view task list.

I am pleased to announce that in the process of procrastinating my
weekly reflection, I've managed to come up with a weekly view of
tasks. Check out the bottom of
http://sacha.free.net.ph/notebook/wiki/2005.10.02.php .

Warning! Probably only works on my browser - Mozilla Firefox. Anyway,
it's a cute little weekly calendar that shows my tasks. There's
probably a much better way to do that, involving perhaps routing it
through diary and deskcal and a few other things. Suggestions would be
very much appreciated, as I'm no expert on CSS.

;; Totally idiosyncratic way to display scheduled tasks on a weekly calendar
;; Example: http://sacha.free.net.ph/notebook/wiki/2005.10.02.php

;; Assembles weekly calendar through clever use of CSS and absolute
;; positioning inside relative-positioned blocks. Tasks should look like
;; #A _ @0800-1300 Something with time
;; #A _ @0800-1300 Q1 Something with Covey quadrants, too!

;; Code quirks: Calls planner-backend-output-file, which is something
;; like muse-output-file in planner-muse and emacs-wiki-published-file
;; in emacs-wiki. If you're not using planner--duo or planner--merge,
;; tweak this...

;; Add this to your CSS:
;; .week_calendar TD A { display: block; position: absolute; width: 100%; overflow: hidden }
;; .week_calendar .timed TD { position: relative; height: 375px; width: 100px }
;; .week_calendar TD { width: 100px; }
;; .week_calendar TD DIV { position: relative }
;; .week_calendar LI { overflow: hidden; }
;; .q1 { background-color: red }
;; .q2 { background-color: yellow }
;; .unknown { background-color: gray }

;; Add this to a planner page:
;; <planner-tasks-table from="." to="+7">

(defun sacha/planner-tasks-table-tag (tag-beg tag-end attrs)
  "Mark up tasks for this week.
Tags are of the form <planner-tasks-table from=\".\" to=\"+7\">."
  (insert "<nowiki>" (sacha/planner-weekly-table (cdr (assoc "from" attrs))
                                                 (cdr (assoc "to" attrs))) "</nowiki>"))

(add-to-list 'planner-markup-tags '("planner-tasks-table" nil t nil sacha/planner-tasks-table-tag))

;; Everything else is bubblegum and duct tape

(defun sacha/planner-weekly-class (task-info)
  "Stylesheet class for TASK-INFO.
A Q1 task is urgent and important - red tasks.
A Q2 task is not urgent but is important - yellow tasks.
Everything else is colored gray."
  (cond
   ((string-match "Q1" (planner-task-description task-info)) "q1")
   ((string-match "Q2" (planner-task-description task-info)) "q2")
   (t "unknown")))

(defun sacha/planner-weekly-timed-task-line (info target)
  "Turn INFO into a block describing the timed task, linking to TARGET."
 (let ((info (or info (planner-current-task-info)))
       start-time end-time
       (pixels-per-hour 20)
       (day-start (* 7 60)))
   (when (string-match "@\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9][0-9][0-9]\\)" (planner-task-description info))
     (setq start-time (string-to-number (match-string 1 (planner-task-description info))))
     (setq end-time (string-to-number (match-string 2 (planner-task-description info))))
     (setq start-time (+ (% start-time 100) (* (/ start-time 100) 60)))
     (setq end-time (+ (% end-time 100) (* (/ end-time 100) 60))))
   (when (and start-time end-time)
     (format "<a href=\"%s\" title=\"%s\" class=\"%s\" style=\"top: %spx; height: %spx\">%s</a>\n"
             target
             (planner-task-description info)
             (sacha/planner-weekly-class info)
             (number-to-string (round (* (/ (- start-time day-start) 60.0) pixels-per-hour)))
             (number-to-string (round (* (/ (- end-time start-time) 60.0) pixels-per-hour)))
             (planner-task-description info)))))

(defun sacha/planner-weekly-timed-tasks-for-day (target)
  "Return a list of all the timed tasks in the current buffer, linked to TARGET."
  (goto-char (point-min))
  (let (lines)
    (while (re-search-forward planner-task-regexp nil t)
      (setq lines (concat lines (or (sacha/planner-weekly-timed-task-line (planner-current-task-info) target) ""))))
    (concat "<div>" lines "</div>")))

;; I thought about using this, but then I dropped it.
(defun sacha/planner-weekly-untimed-tasks-for-day (target)
  "Return a list of all the untimed tasks in the current buffer, linked to TARGET."
  (goto-char (point-min))
  (let (lines)
    (while (re-search-forward planner-task-regexp nil t)
      (let ((info (planner-current-task-info)))
        (unless (string-match "@\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9][0-9][0-9]\\)"
                              (planner-task-description info))
          (setq lines (concat lines
                              (format "<li><a href=\"%s\" title=\"%s\" class=\"%s\">%s</a></li>"
                                      target
                                      (planner-task-description info)
                                      class
                                      (planner-task-description info)))))))
    (concat "<ul>" lines "</ul>")))

(defun sacha/planner-weekly-table (from to)
  "Create a table with timed task entries defined by FROM and TO."
  (let ((pages (planner-get-day-pages (planner-expand-name from) (planner-expand-name to)))
        result-timed
        result-untimed
        header
        date)
    (with-temp-buffer
      (with-planner
        (while pages
          (erase-buffer)
          (insert-file-contents (planner-page-file (car pages)))
          (setq date (planner-filename-to-calendar-date (car pages)))
          (setq header (concat (format "<th><a href=\"%s\">%s %d</a></th>"
                                       (planner-backend-output-file (car pages))
                                       (calendar-day-name date t)
                                       (extract-calendar-day date)) header))
          (setq result-timed
                (concat "<td>" (sacha/planner-weekly-timed-tasks-for-day
                                (planner-backend-output-file (car pages))) "</td>"
                        result-timed))
          (setq pages (cdr pages))))
      (setq result (concat "<table class=\"week_calendar\"><tr>" header
                           "</tr><tr class=\"timed\">" result-timed
                           "</tr></table>")))
    result))

==================


... and if someone can get it to look like iCal, that would be
_ultra_cool.

Wow. Having a weekly overview lets me see just how badly I'm doing in
terms of urgency. Must fix.

GTD and homebrew fans: Sorry, I'm channeling Franklin-Covey today. =)
That's what I get for finally getting myself my own copy of First
Things First, having read it N times in the library and in
bookstores... If I can make space in my book budget for David Allen's
book, then we might see more GTD-ish stuff. ;)

How I threw this stuff together:

I copied one of my published pages and hand-hacked the HTML until I
figured out the CSS for displaying the weekly schedule. (I used the
trick in another application before, but forgot how to do it.) I then
wrote successively larger chunks of code.

First I wrote a function that took the current task line and copied
the HTML version to the clipboard. When that worked, I changed it to
return the result and I wrote another function that concatenated all
the results from the tasks on the same page, copying _that_ to the
clipboard. Then I changed that function to return the result and I
wrote another function to iterate through day pages, again copying the
result to the clipboard. When that worked, I wrote a markup tag,
copying the example I remembered from planner-notes-index.el.

It's fun to prototype things in Emacs. Emacs lets me build code from
the bottom up. =)
===========

> Subject: {{Tasks:xx}}
> I know I turned this on somewhere, but I don't like seeing it in my tasks list.

You might like the following code. Replace the filename with one to a
suitably small image, or grab
http://sacha.free.net.ph/notebook/pics/screen/id-small.png . =)

;;;_+ Marking up IDs as images

(defun planner-id-image (id)
  "Return the image to mark up ID as, or nil if none."
  (save-match-data (when (string-match "Tasks" id) "~/notebook/pics/screen/id-small.png")))

(defun planner-id-highlight-images (beg end &optional verbose)
  "Highlight IDs as pictures from BEG to END.
VERBOSE is ignored."
  (goto-char beg)
  (while (re-search-forward "{{[^}]+}}" end t)
    (let ((image (planner-id-image (match-string 0))))
      (when image
        (emacs-wiki-inline-image (match-beginning 0)
                                 (match-end 0)
                                 image
                                 (match-string 0))))))

(add-hook 'planner-mode-hook
          (lambda () (add-hook 'emacs-wiki-highlight-buffer-hook
                               'planner-id-highlight-images)))
==============

Another vote for a separate planner-config.el for the sake of
organization and such.

Here is snip from my .emacs (pretty sure I stole this from Sacha) that
loads configs that I keep in a dir that is on my load-path:

;; Modular config loader
(mapcar
 (lambda (library)
   (condition-case nil
       (unless (load library t)
         (message "Awww, %s didn't load." library))
     (error nil)))
 (list
  "email-config"
  "bbdb-config"
  "tramp-config"
  "planner-config"))
========
;;; planner-frame.el --- Devote a frame to the Planner

;;;_* Copyrights
;; Copyright (C) 2005 Jesse Alama <alama@stanford.edu>

;;;_* Relation to GNU Emacs
;; This file is not part of GNU Emacs.

;;;_* License
;; This is free software; you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation; either version 2, or (at your option) any later
;; version.
;;
;; This is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
;; for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
;; MA 02111-1307, USA.

;;;_* Commentary:
;;
;; I find it helpful to look at my planner within one frame, taking up
;; the only window of that frame.  I want to treat the Planner as an
;; application in the sense of giving it its own frame and dealing
;; with that frame intelligently.  I've been thus far dissatisfied
;; with other approaches (e.g., `C-x 5 2 RET M-x plan'), so I decided
;; to try my hand at making an extension of planner that does things
;; the way I want.
;;
;; What is the way I want?  Answer: gnus.  The code that follows is
;; based on the way that gnus regards itself as an application: it
;; provides a function `gnus-other-frame' for reading mail and news in
;; a distinguished frame, `gnus-exit-gnus' to save one's configuration
;; and stop reading mail and news and, and `gnus-suspend-gnus' for
;; making the interface go away temporarily while leaving most of its
;; state intact.  I also find it easy to deal with emacs-w3m, which I
;; regard as another emacs application.
;;
;; Currently planner doesn't seem to fit this way of thinking (or at
;; least: I wasn't smart enough or informed enough to see how Planner
;; could be viewed this way), so I created planner-frame.  The purpose
;; is to enable one to think of the Planner as an emacs application in
;; a way similar to how one can view gnus and emacs-w3m as emacs
;; applications.  (A good deal of the code here is directly adapted,
;; if not outright copied, from gnus.  We have here yet another case
;; where the ability to study and adapt code from other applications
;; was a source of enlightenment, satisfaction, and, I hope, value to
;; others.)
;;
;; The user functions are `plan-other-frame',
;; `planner-suspend-planner', and `planner-exit-planner'.  I've also
;; added a couple new keybindings for the latter two functions.  By
;; analogy with gnus, for these two "quit" functions I've created the
;; hooks `planner-exit-planner-hook' and
;; `planner-suspend-planner-hook'.  Customize
;; `planner-frame-parameters' to modify the frame produced by
;; `plan-other-frame'.
;;
;;
;;;_ + Usage
;;
;; To get started, simply add the form
;;
;;   (require 'planner-frame)
;;
;; to your emacs initialization file.  The function `plan-other-frame'
;; will then get your started planning in a distinguished planner
;; frame.
;;
;;;_* Todo
;;
;;;_ + Integrate with `planner.el'
;;
;; It could be valuable to somehow integrate the code here with
;; `planner.el', ala gnus, which provides `gnus-other-frame' and its
;; supporting code alongside `gnus'.
;;
;;;_ + Offer a way to make the planner frame permanently visible.
;;
;;;_ + Launch applications in other frames
;;
;; It would be nice to make things so that following links to data
;; outside the Planner project (either in the emacs-wiki or muse
;; sense) pops up a new frame.  The idea here is to make the Planner,
;; in its own frame, a kind of repellant force: the only things that
;; really go in that frame are Planner pages; trying to go outside the
;; planner lands one in a different frame.  Enforcing such
;; restrictions could be helpful; thus there would be little chance of
;; getting distracted, with one's planner pages buried deep uneath a
;; pile of erc, bbdb, message, and other buffers.  It would allow one
;; to better focus on planning and what needs to be done.  It would
;; make the Planner a kind of omnipresent application.
;;
;;;_ + Integration with other applications
;;
;; (Alert: vague rambling follows.)  My idea is to somehow collect PIM
;; applications together.  The Planner isn't the only one: there's the
;; diary and the calendar (already an example of two PIM applications
;; working together), the BBDB, timeclock, and so on.  Somehow it
;; would be nice to gather these together in a single package.  Of
;; course already there is quite a lot of glue between these provided
;; by Planner; that's the purpose of, for example, remember with its
;; annotation functions.  But it seems to me that the connections
;; could be even tighter.  One sense in which the connections could be
;; tighter is the frame and window code; it would be great if,
;; somehow, Planner were the uber-application in its own frame, and it
;; had some "servant" frames.
;; 
;;;_ + User input
;;
;; I'd love to hear how you've used planner-frame.el, and how you
;; think it can be improved!  My email address is at the beginning of
;; the file.

;;;_* Dependencies

(require 'planner)

;;;_* User Variables

(defcustom planner-frame-parameters nil
  "Frame parameters used by `plan-other-frame' to create a Planner frame.
This should be an alist for Emacs, or a plist for XEmacs."
  :group 'planner
  :type (if (featurep 'xemacs)
	    '(repeat (list :inline t :format "%v"
			   (symbol :tag "Property")
			   (sexp :tag "Value")))
	  '(repeat (cons :format "%v"
			 (symbol :tag "Parameter")
			 (sexp :tag "Value")))))

(defcustom planner-exit-planner-hook nil
  "Hook called when exiting Planner."
  :group 'planner
  :type 'hook)

(defcustom planner-suspend-planner-hook nil
  "Hook called when suspending Planner."
  :group 'planner
  :type 'hook)

;;;_* Default Keybindings

(define-key planner-mode-map "\C-cz" 'planner-suspend-planner)
(define-key planner-mode-map "\C-cx" 'planner-exit-planner)

;;;_* Internal Functions

(defun planner-select-frame-set-input-focus (frame)
  "Select `planner-frame', raise it, and set input focus, if possible."
  ;;; taken verbatim from `gnus-select-frame-set-input-focus'
  (cond ((featurep 'xemacs)
	 (raise-frame frame)
	 (select-frame frame)
	 (focus-frame frame))
	;; The function `select-frame-set-input-focus' won't set
	;; the input focus under Emacs 21.2 and X window system.
	;;((fboundp 'select-frame-set-input-focus)
	;; (defalias 'gnus-select-frame-set-input-focus
	;;   'select-frame-set-input-focus)
	;; (select-frame-set-input-focus frame))
	(t
	 (raise-frame frame)
	 (select-frame frame)
	 (cond ((and (eq window-system 'x)
		     (fboundp 'x-focus-frame))
		(x-focus-frame frame))
	       ((eq window-system 'w32)
		(w32-focus-frame frame)))
	 (when focus-follows-mouse
	   (set-mouse-position frame
			       (1- (frame-width frame)) 0)))))

(defun planner-frame-or-window-display-name (object)
  "Given a frame or window, return the associated display name.
Return nil otherwise."
  (if (featurep 'xemacs)
      (device-connection (dfw-device object))
    (if (or (framep object)
	    (and (windowp object)
		 (setq object (window-frame object))))
	(let ((display (frame-parameter object 'display)))
	  (if (and (stringp display)
		   ;; Exclude invalid display names.
		   (string-match "\\`[^:]*:[0-9]+\\(\\.[0-9]+\\)?\\'"
				 display))
	      display)))))

(defun planner-buffer-p (buf)
  (with-current-buffer buf
    (string-match mode-name "planner")))

(defun planner-alive-p ()
  "Determine whether Planner is running" 
  ;; planner is running iff there is a buffer anywhere whose mode is
  ;; `planner-mode'.
  (let ((buf-list (buffer-list))
	(found nil))
    (while (and buf-list (not found))
      (let ((buf (car buf-list)))
	(when (planner-buffer-p buf)
	  (setq found t)))
      (setq buf-list (cdr buf-list)))
    found))

;;;_* Internal Variables

(defvar planner-most-recent-buffer nil
  "The most recent planner buffer that has been visited.")

(defvar planner-frame nil
  "A frame object which will be created by `plan-other-frame'.")

;;;_* Public Functions

;;;###autoload
(defun plan-other-frame (&optional force-days display)
  "Like `plan', but does so in a new frame.

This will call `plan' and pop up a Planner frame; the value of
FORCE-DAYS is passed to `plan'.  The optional second argument
DISPLAY should be a standard display string such as \"unix:0\" to
specify where to pop up a frame.  If DISPLAY is omitted or the
function `make-frame-on-display' is not available, the current
display is used."
;; Docstring taken from docstring of `gnus-other-frame'.
  (interactive "P")
  (if (fboundp 'make-frame-on-display)
      (unless display
	(setq display (planner-frame-or-window-display-name (selected-frame))))
    (setq display nil))
  (let ((alive (planner-alive-p)))
    (unless (and alive
		 (catch 'found
		   (walk-windows
		    (lambda (window)
		      (when
			  (and
			   (or (not display)
			       (equal display
				      (planner-frame-or-window-display-name
				       window)))
			   (with-current-buffer (window-buffer window)
			     (string-match "\\`planner-"
					   (symbol-name major-mode))))
			(planner-select-frame-set-input-focus
			 (setq planner-frame (window-frame window)))
			(select-window window)
			(throw 'found t)))
		    'ignore t)))
      (planner-select-frame-set-input-focus
       (setq planner-frame
	     (if display
		 (make-frame-on-display display planner-frame-parameters)
	       (make-frame planner-frame-parameters))))
      (if alive
	  (switch-to-buffer planner-most-recent-buffer)
	(plan force-days)))))

;;;###autoload
(defun planner-exit-planner ()
  "Save and then close all Planner buffers, delete the frame that
Planner created, and run the hook `planner-exit-planner-hook'."
  (interactive)
  (planner-save-buffers)
  (when (and (frame-live-p planner-frame)
	     (cdr (frame-list)))
    (delete-frame planner-frame))
  (dolist (buf (buffer-list))
    (when (planner-buffer-p buf)
      (kill-buffer buf)))
  (setq planner-frame nil)
  (run-hooks 'planner-exit-planner-hook))

;;;###autoload
(defun planner-suspend-planner ()
  "Delete the frame that was created for the Planner, then run the
hook `planner-suspend-planner-hook'."
  (interactive)
  (when (and (frame-live-p planner-frame)
	     (cdr (frame-list)))
    (delete-frame planner-frame))
  (run-hooks 'planner-suspend-planner-hook))

;;;_* Export Statements
(provide 'planner-frame)

;;;_* Local emacs vars.

;; Local variables:
;; allout-layout: (* 0 : )
;; End:

;;; planner-frame.el ends here
=========
It sounds like M-x planner-diary-add-entry is probably what you are looking
for. That's what I use most of the time to add appointments to the diary.
=======

Not sure, if you do M-x toggle-debug-on-error and post the Backtrace, maybe we
can help better.

============

Oh yes, I have just looked at the 21.4 info files and it has the same
as yours there too.

So, to summarize:

Gnu Emacs < 22 ::
  (display-time)
  (add-hook 'diary-hook 'appt-make-list)
  (diary 0) ; probably only necessary for appointments in the diary file

Gnu Emacs >= 22 ::
  (appt-activate 1)

============


A totally cheap way to do it is to export appointments to remind and
use remind to generate monthly calendars. =) I think remind can also
publish as HTML.

Useful files:

http://richip.dhs.org/~sachac/notebook/emacs/remind.el
http://richip.dhs.org/~sachac/notebook/emacs/plan2rem
http://richip.dhs.org/~sachac/notebook/emacs/rem2diary   (optional)

question: not too many entries, use calendar? print laTex?
============


If you use planner-appt, you can call planner-appt-forthcoming-display
with a prefix argument:

C-u 3 0 M-x planner-appt-forthcoming-display

would show appointments in the next 30 days, for example.
==========

As for crisis management tracking: I have a totally small-time
schedule visualizer that works off tasks with times like @1000-1400
and Q1, Q2, Q3, or Q4 somewhere in the task description.

If you can actually get this to work on your system, totally cool. =)

;; Totally idiosyncratic way to display scheduled tasks on a weekly calendar
;; Example: http://sacha.free.net.ph/notebook/wiki/2005.10.02.php

;; Assembles weekly calendar through clever use of CSS and absolute
;; positioning inside relative-positioned blocks.

;; Add this to your CSS:
;; .week_calendar TD A { display: block; position: absolute; width: 100%; overflow: hidden }
;; .week_calendar .timed TD { position: relative; height: 375px; width: 100px }
;; .week_calendar TD { width: 100px; }
;; .week_calendar TD DIV { position: relative }
;; .week_calendar LI { overflow: hidden; }
;; .q1 { background-color: red }
;; .q2 { background-color: yellow }
;; .unknown { background-color: gray }

;; Add this to a planner page:
;; <planner-tasks-table from="." to="+7">

(defun sacha/planner-tasks-table-tag (tag-beg tag-end attrs)
  "Mark up tasks for this week.
Tags are of the form <planner-tasks-table from=\".\" to=\"+7\">."
  (insert "<nowiki>" (sacha/planner-weekly-table (cdr (assoc "from" attrs))
                                                 (cdr (assoc "to" attrs))) "</nowiki>"))

(add-to-list 'planner-publish-markup-tags '("planner-tasks-table" nil t sacha/planner-tasks-table-tag))

;; Everything else is bubblegum and duct tape

(defun sacha/planner-weekly-class (task-info)
  "Stylesheet class for TASK-INFO.
A Q1 task is urgent and important - red tasks.
A Q2 task is not urgent but is important - yellow tasks.
Everything else is colored gray."
  (cond
   ((string-match "Q1" (planner-task-description task-info)) "q1")
   ((string-match "Q2" (planner-task-description task-info)) "q2")
   (t "unknown")))

(defun sacha/planner-weekly-timed-task-line (info target)
  "Turn INFO into a block describing the timed task, linking to TARGET."
 (let ((info (or info (planner-current-task-info)))
       start-time end-time
       (pixels-per-hour 20)
       (day-start (* 7 60)))
   (unless (string= (planner-task-status info) "C")
     (when (string-match "@\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9][0-9][0-9]\\)" (planner-task-description info))
       (setq start-time (string-to-number (match-string 1 (planner-task-description info))))
       (setq end-time (string-to-number (match-string 2 (planner-task-description info))))
       (setq start-time (+ (% start-time 100) (* (/ start-time 100) 60)))
       (setq end-time (+ (% end-time 100) (* (/ end-time 100) 60))))
     (when (and start-time end-time)
       (format "<a href=\"%s\" title=\"%s\" class=\"%s\" style=\"top: %spx; height: %spx\">%s</a>\n"
               target
               (planner-task-description info)
               (sacha/planner-weekly-class info)
               (number-to-string (round (* (/ (- start-time day-start) 60.0) pixels-per-hour)))
               (number-to-string (round (* (/ (- end-time start-time) 60.0) pixels-per-hour)))
               (planner-task-description info))))))

(defun sacha/planner-weekly-timed-tasks-for-day (target)
  "Return a list of all the timed tasks in the current buffer, linked to TARGET."
  (goto-char (point-min))
  (let (lines)
    (while (re-search-forward planner-task-regexp nil t)
      (setq lines (concat lines (or (sacha/planner-weekly-timed-task-line
                                    (planner-current-task-info) target) ""))))
    (concat "<div>" lines "</div>")))

;; I thought about using this, but then I dropped it.
(defun sacha/planner-weekly-untimed-tasks-for-day (target)
  "Return a list of all the untimed tasks in the current buffer, linked to TARGET."
  (goto-char (point-min))
  (let (lines)
    (while (re-search-forward planner-task-regexp nil t)
      (let ((info (planner-current-task-info)))
        (unless (string-match "@\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9][0-9][0-9]\\)"
                              (planner-task-description info))
          (setq lines (concat lines
                              (format "<li><a href=\"%s\" title=\"%s\" class=\"%s\">%s</a></li>"
                                      target
                                      (planner-task-description info)
                                      class
                                      (planner-task-description info)))))))
    (concat "<ul>" lines "</ul>")))

(defun sacha/planner-weekly-table (from to)
  "Create a table with timed task entries defined by FROM and TO."
  (let* ((planner-dates-relative-to-today-flag nil)
         (pages (planner-get-day-pages (planner-expand-name from) (planner-expand-name to)))
         result-timed
         result-untimed
         header
         date)
    (with-temp-buffer
      (with-planner
        (while pages
          (erase-buffer)
          (insert-file-contents (planner-page-file (car pages)))
          (setq date (planner-filename-to-calendar-date (car pages)))
          (setq header (concat (format "<th><a href=\"%s\">%s %d</a></th>"
                                       (concat (car pages) ".php")
                                       (calendar-day-name date t)
                                       (extract-calendar-day date)) header))
          (setq result-timed
                (concat "<td>" (sacha/planner-weekly-timed-tasks-for-day
                                (concat (car pages) ".php")) "</td>"
                        result-timed))
          (setq pages (cdr pages))))
      (setq result (concat "<table class=\"week_calendar\"><tr>" header
                           "</tr><tr class=\"timed\">" result-timed
                           "</tr></table>")))
    result))
===============


elscreen?  Note that, with my config Emacs 21.3, I had to remove the
smtp.el and smtpmail.el files that comes with FLIM as they override
the files that comes with emacs.

I had to delete some more files from FLIM and APEL. Just use M-x
list-load-path-shadows to find packages from FLIM and APEL that shadow
other more recent files. (StefanReichoer) 

===== 

I've been tagging my notes like this:

.#1  Some Awesome Title
{tags:writing, important statement, takingovertheworld}
foo bar. foo awesome foo hawt monkey note note note

How easy/difficult would it be to make planner do this:

M-x dyd/planner-search-note-tags RET takingovertheworld RET

which would output a buffer that looks something like this:

** [[2005.07.16#3]]	Quote from [[Writing the Sacred Journey]]
** [[2006.01.19#20]]      Picking my nose gently
** [[2006.03.15#1]]     Some Awesome Title
etc.
==================
Speaking of tags, I've been using

(defun sacha/planner-technorati-tag (beg end &optional attrs)
  (interactive)
  (let ((list (cdr (assoc "s" attrs))))
    (planner-insert-markup
     "On Technorati: "
     (mapconcat (lambda (string)
                  (concat
                   "<a href=\"http://technorati.com/tag/"
                   (planner-replace-regexp-in-string " " "+" string)
                   "\" rel=\"tag\">"
                   string "</a>"))
                (split-string list ",")
                ", "))))

(add-to-list 'muse-publish-markup-tags '("tag" nil t sacha/planner-technorati-tag))

to tag my notes with <tag s="foo,bar,baz">

One of these days I plan to write something that will actually index
the tagged blog entries and display a tag cloud or something like
that.

In retrospect, though, using something that can easily be grepped
would be a better idea. So: tag:writing tag:important
tag:takingovertheworld, or even ::writing ::important
::takingovertheworld - much easier to grep for it because you can, say,

grep ::writing * | grep ::important | grep -v ::takingovertheworld

to grab all of the stuff where you write about important stuff that is
_not_ about taking over the world! ;) 'course, you don't get titles,
but it should be easy enough to pull that out if you make a little
notes index...
========
> The documentation provides a way to set up one muse project for
> planner, and explicitly says "This is fine if you only want one muse
> project" or something similar. I want other, non-planner-related
> muse projects, and have not found the lisp for doing that. What do I
> need to do that's faster than learn Lisp? (although I'm doing that
> as well).

See the Muse manual for another example of a muse-project-alist
setting.  For still more examples that come with Muse, see
examples/mwolson/muse-init.el and examples/johnw/muse-johnw.el.

===========


(setq muse-project-alist
      '(("opsdocs"
        ("~/work/muse" :default "index")
        (:base "html" :path "~/public_html/muse")
        (:base "pdf" :path "~/public_html/muse/pdf"))

        ("userdocs"
        ("~/work/muse/UserDocs" :default "index")
        (:base "html" :path "~/public_html/UserDocs")
        (:base "pdf" :path "~/public_html/UserDocs/pdf"))

	("WikiPlanner"        ;; use value of `planner-project'
         ("~/Plans"           ;; where your Planner pages are located
          :default "TaskPool" ;; use value of `planner-default-page'
          :major-mode planner-mode
          :visit-link planner-visit-link)

         ;; This next part is for specifying where Planner pages
         ;; should be published and what Muse publishing style to
         ;; use.  In this example, we will use the XHTML publishing
         ;; style.
	 
         (:base "xhtml"
                ;; value of `planner-publishing-directory'
                :path "~/public_html/Plans"))))

I have 3 different "projects".  The last is my planner project, the
other two are just pure documentation projects where I use emacs as a
wiki engine for writing docs (which no one reads :)
I then publish internally to my website.

===========


after managing to keep all my personal information in Emacs (hooray to
planner, muse, gnus, and bbdb!), I came to the conclusion that the outside
world still uses other tools, and they often ask me for some portions of
information. One of such is my schedule. So I promised to give them an
iCalendar .ics file, and dug into Emacs to code some elisp to make it
work. First, I found icalendar.el, and then planner-ical. Both wouldn't work
for me:
1)  icalendar.el provides a simple API, directed to diary<->icalendar
    migration. It doesn't merge information :(
2) planner-ical.el is a work in progress, I suppose. It only converts tasks
   into VTODO, and only from one page at a time.

So I thought about what I needed:
o export all my future appointments into VEVENTs. This includes cyclic events,
  and tasks with time informations (both handled with planner-appt).
o import a full icalendar into planner. deal with VEVENT, VTODO, VJOURNAL, and
  create, respectively, schedule entries, tasks and notes. add the appointments
  retrieved from the VALARMS.


The code I made today fulfills, although not wonderfully, my first
requirement. I'm using it specially to communicate my availability to my
co-workers. So I added a regexp argument to filter each entry by its planner
category! The only thing I can't seem to manage is to get planner-appt to tell
me the category of a task-appointment. So right now I export all of the tasks!
Anyone knows how I can get this behavior?

Here's the code to export to a ics file:


;; iCalendar export of appointments:
(require 'icalendar)
;; TODO: Each VEVENT and VTODO will have a VALARM if it has an associated
;; appointment."

(defun planner-export-ical (category-regexp n ical-output-file)
  "Write ICAL-OUTPUT-FILE with iCalendar format. CATEGORY_REGEXP will
limit category marked entries, enabling filtering of the exported
data (up until N days from now).
The iCalendar exported data are all the planner task appointments and
all the cyclic diary entries (in `planner-cyclic-diary-file').
They are exported as VEVENTs."
  (interactive)
  ;; Get the appointments until end-date:
  (let ((appts (planner-appt-forthcoming-get-appts n (planner-today))))

    ;; And now add the cyclic appointments from the appropriate file:
    (with-temp-buffer
      (let ((cyclic-appts nil))
	(with-temp-buffer
	  (find-file planner-cyclic-diary-file)
	  (dolist (line (split-string (buffer-string) "[\n\r]"))
	    (unless (or (string= line "")
			(string-match "^!" line))
	      (push line cyclic-appts)))
	  (kill-buffer (current-buffer)))
	(dolist (appt-desc cyclic-appts)
	  (let ((appt-category (when (string-match "\\(.*\\)[ \t]*(\\(.*\\))$" appt-desc)
				 (match-string 2 appt-desc)))
		(appt-text (match-string 1 appt-desc)))
	    ;; Now filter by categories regexp:
	    (when (string-match category-regexp appt-category)
	      (when (string-match "\\(.*\\) @\\([0-2]?[0-9]:[0-5]?[0-9]\\)[ \t]*[-|][ \t]*\\([0-2]?[0-9]:[0-5]?[0-9]\\)[ \t]*|?[ \t]*\\(.*\\)$" appt-text)
		(let ((day        (match-string 1 appt-text))
		      (start-time (match-string 2 appt-text))
		      (end-time   (match-string 3 appt-text))
		      (text       (match-string 4 appt-text)))
		  (setq appt-text (format "%s %s-%s %s\n" day start-time end-time text))
		  (message "Adding cyclic appt to temp diary:::: %s" appt-text)
		  (insert appt-text)))))))	
      (dolist (appt appts)
	(let* ((appt-date (first appt))
	       (appt-desc (second appt))
	       (appt-category (when (string-match "\\(.*\\)(\\(.*\\))$" appt-desc)
				(match-string 2 appt-desc)))
	       (appt-text (when (string-match "\\(.*\\)\\((.*)\\)?$" appt-desc)
				(match-string 1 appt-desc))))
	  ;; Filter task appointments only:
	  (when (and appt-text
		     (string-match "\@?\\(.*\\)[ 	]*|?[ 	]#[	 ]*[-|]?\\(.*\\)$" appt-text))
	    ;; Now filter by categories regexp:
	    (if (or (null appt-category)
		    (string-match category-regexp appt-category))

		;; Extract time and text strings:
		(let ((appt-time (match-string 1 appt-text))
		      (appt-text (match-string 2 appt-text)))
		  
		  (setq appt-time (replace-in-string appt-time "|" ""))
		  (setq appt-time (replace-in-string appt-time " [ ]*" " "))
		  (setq appt-time (replace-in-string appt-time " $" ""))
		  (setq appt-time (replace-in-string appt-time " " "-"))
		  (setq appt-date (apply #'format "%s/%s/%s" (planner-filename-to-calendar-date appt-date)))
		  (message "Adding task to temp diary:::: %s %s %s" appt-date appt-time appt-text)
		  (insert (format "%s %s %s\n" appt-date appt-time appt-text)))
		(message "NOT adding task to temp diary:::: %s" appt-desc)))))
      (icalendar-export-region (point-min)
			       (point-max)
			       ical-output-file))))

;; icalendar fix (this function wouldn't work properly under my Windows + GNU
;; Emacs configuration, so I just removed a silly comparison:
(defalias 'icalendar--rris 'replace-regexp-in-string)

;; Usage example (export ical for the next 31 days):
;;  (planner-export-ical "." 31 "~/exported-planner-appts.ics")
===========

I agree that that would be the ideal approach, but it wouldn't find
cyclical appointments on pages that don't exist yet. One would have to
visit each page with a matching cyclical entry first so that they get
created.  So it might actually be better to use Edgar's approach. 

===========

>
> I think ideally we would do this as a Muse publishing style.

Well, the exporting would be great as a muse publishing style. However, what I
was trying to have (in a long-term point of view) is a full synchronization
system: from an iCalendar file to planner and back again! And I'm not seeing
Muse as the proper tool to deal with such a system... But I'm ok with Muse
being able to publish each planner data type (i.e., task, note or schedule
entry) into the appropriate VCALENDAR node. I could even like Muse to publish
the full iCalendar, if there were a separate merge tool between two
iCalendar's. But I think it would be easier to do the merge with the planner
data, instead of doing it with a couple of text files. Note that this wouldn't
be the only synch-system we (planner users) would need. I'd like to sync my
Symbian SonyEricsson's PIM with planner+bbdb+gnus, one day, for instance!
There's also Yahoo! calendar+etc., Google calendar, etc, etc... This leads me
to one question: is a synchronizing framework needed for Emacs? :)

No matter what the final approach is, I'm now pretty happy with my exporter (it
lacks notes exporting, I haven't got the need to do that, so far).

My next goal now would be to import an ical into a temp diary file, and use
calendar and my modified version of weekly-view to display the entries. From
there, I'd like to have a link/keyboard shortcut to import that (possibly
cyclic) diary entry into my planner. Do you have any suggestions to improve
this behavior?

===============

> Has the publication of a WikiIndex.html been lost in the switch to
> muse?

Add a :force-publish ("WikiIndex") line to your muse-project-alist
(see examples/mwolson/muse-init.el for an example), and then make a
file called WikiIndex.muse that contains the following.

#title Index

<lisp>(muse-index-as-string t t)</lisp>

===========

> Is it possible to exclude all the planner day pages from the index?  Or to
> reproduce the emacs-wiki behaviour where the resultant page looked something
> like:
>
> | PageOne
> | PageTwo
> | 2006-01: 01 02 04 05 06
> | 2005-12: 25 26 28 29

Use `planner-index-as-string' to get the latter behavior.

 #title Index

 <lisp>(planner-index-as-string t t)</lisp>


===========

>
> What I've always done is load all the planner source files into Emacs and
> invoke Emacs-lisp-byte-compile on each one by recording and repeating a
> keystroke macro.  But I suppose invoking byte-force-recompile would be
> quicker.

I usually open the lisp directory in dired, mark all *.el files (with % m .el$)
and then byte compile them with B.

===========


> Does there exist some doku which explains the syntax for a planner
> task (i.e. a task in the TaskPool) somewhat formally? What form must
> a task have to be automatically bi-directionally linked/linkable to
> other pages (e.g. the page of today).  I would like to be able to
> manually edit the task and have changes always reflected by the
> linked page (required use of an ID is fine).

See the "Example Page" section in the Planner manual.  It should
probably be modified, however, to better explain the syntax of a
single task line.

Here is a sort of Task syntax, using nested definition lists to form a
modified sort of BNF grammar that is publishable by Muse, as of 10
minutes ago.

#disable-tables t
; tell Muse not to turn "|" into a table; ignore if you are
; casually reading this via email

<TASK> :: #<PRIORITY> " " <STATUS> " " <DESCRIPTION>

  <PRIORITY> :: A | B | C

    A :: high priority
    B :: medium priority
    C :: low priority

  <STATUS> :: _ | D | X | P | C | o

    _ :: open
    D :: delegated
    X :: done
    P :: pending
    C :: cancelled
    o :: in progress

  <DESCRIPTION> :: <text> ( "{{" <TAG> "}}" )* ( "(" <PARTNERS> ")" )?

    <TAG> :: ( Tasks:<TASK_ID> | Deadline:<DATE> | ... )

    <PARTNERS> ::
      (simple case) :: <PAGE_NAME>

      (with planner-multi) :: ( <PAGE_NAME> <PAGE_SEPARATOR> )*
                              <PAGE_NAME>

         <PAGE_SEPARATOR> (by default) :: " "

> What kind of pages can be linked such that edits are reflected
> automatically? The usual case is some date (like today). However, I
> would like to organise my plans, for example, in larger time frames
> like having as link [[May.2006]]. I once succeeded in creating such
> a task and editing the task was then reflected in the file/buffer
> May.2006. Still, I couldn't reproduce that :-/

A task must have a task ID in order for edits to be automatically
propagated between instances of the same task in different files.

To add this ID, either create tasks using M-x planner-create-task or
run M-x planner-id-add-task-id after moving to the task.


===========


> I see, it should not create a task ID by hand. Still, can I have
> some arbitrarily named 'partner' page name and can I manually enter
> that like
>
> #B _ some test [[May.2006]]
>
> 	------

Don't forget to surround the link with parentheses.  Yeah, that should
work.  When you save the file, Planner should propagate the task to
the partner page.

> Besides, having multiple related pages would be interesting for
> me. Unfortunately, I didn't got that working. Do I simply add
> multiple links to the end of the task like
>
> #B _ some test [[link 1]] [[link 2]]
>
> When I try this, the links work but the task is not listed on that
> page.

That should be ([[link 1]] [[link 2]]).

> BTW: the doc introduces the function
> planner-multi-copy-tasks-to-page', but that seems not to exist on my
> planner.

`planner-multi-copy-tasks-to-page' is a customizable option, not a
function.


===========

> I'd like to exclude certain Planner files in a project from being
> published to html. In particular, I would like to make a website out
> of just the plan pages, not the day pages. I also want to exclude
> certain private day pages (for example, HealthCare.muse).

Change your publishing rule for the particular entry of
`muse-project-alist' to be something like the following.  I should
document this.

 (:base "planner-html"
        :path "~/publishing-path/.../"
        :exclude "/\\([1-9][0-9][0-9][0-9]\\.[0-9]+\\.[0-9]+\\|private/\\)")

> Also, I can't seem to get it to publish a WikiIndex anymore. It used
> to do this automatically.

Make sure you have the following in the first part of the
muse-project-alist entry.

 :force-publish ("WikiIndex")

The WikiIndex.muse page also needs to exist, and have
<lisp>(muse-index-as-string t t)</lisp> in it.


===========

> I'd like to exclude certain Planner files in a project from being
> published to html. In particular, I would like to make a website out
> of just the plan pages, not the day pages. I also want to exclude
> certain private day pages (for example, HealthCare.muse).

Change your publishing rule for the particular entry of
`muse-project-alist' to be something like the following.  I should
document this.

 (:base "planner-html"
        :path "~/publishing-path/.../"
        :exclude "/\\([1-9][0-9][0-9][0-9]\\.[0-9]+\\.[0-9]+\\|private/\\)")

> Also, I can't seem to get it to publish a WikiIndex anymore. It used
> to do this automatically.

Make sure you have the following in the first part of the
muse-project-alist entry.

 :force-publish ("WikiIndex")

The WikiIndex.muse page also needs to exist, and have
<lisp>(muse-index-as-string t t)</lisp> in it.

==========


Actually this is working now. I had to tweak your regexp (wrapped it
in forward slashes.)

Here's my muse-project-alist setting line, for those who want to
exclude day pages and particular plan pages: 

Thanks mwolson!

(add-hook 'muse-project-alist
	  (list planner-project
		(list planner-directory
		      :default planner-default-page
		      :major-mode 'planner-mode
		      :visit-link 'planner-visit-link
		      :force-publish '("WikiIndex"))
		(list :base "planner-xhtml" 
		      :path "/ssh:dto@tty.freeshell.org:~/html/wiki/"
		      :exclude "/\\([1-9][0-9][0-9][0-9]\\.[0-9]+\\.[0-9]+\\|HealthCare\\)/"
		      )))


===========

>
> (add-hook 'muse-project-alist


Shouldn't that be (setq muse-project-alist ...) ?


===========

> I'm interested in using muse (hence muse-journal) as an integrated
> "static" weblog engine, that doesn't need other software to publish
> an entire blog.  I noticed how your blog was designed (at
> mwolson.org) and I've looked at the examples/ directory of the muse
> mode distribution tarball, but it is not obvious to me how you
> handled things such as:
>
> * Pagination (say, the index page shouldn't have more than 10
> entries)
>
> * Generation of archive summary pages and permalinks.

These are both handled by pyblosxom, since I use muse-blosxom.el
rather than muse-journal.el.  If you want an example muse-journal.el
setup, check out examples/johnw/.

Also, make sure you look at the "9.5 Keeping a journal or blog"
section in the Muse manual.  It thoroughly explains the options
available.  Couple that with johnw's example journal project entry in
muse-project-alist, and a journal should be relatively painless to set
up.

> I'd like to receive advices on how I must accomplish this (in case
> it isn't built-in in Muse mode, make it a feature request :-)).  As
> I explained, it would be great not to rely on other software (such
> as pyblosxom).  I'm new to Emacs Lisp, and haven't read the Emacs
> Lisp Reference Manual yet, but I've been using Common Lisp and
> Scheme for some time.  Also tell me if you plan to implement this in
> the future.

muse-journal.el currently does not handle pagination, or moving old
entries to a particular page.  If I recall correctly, johnw
(http://johnwiegley.com/) moves his older entries into a separate file
a few times each year.

==============

> it appears planner-report changes my tasks in an (for me at least) 
> unwanted way. On the day page(s) it replaced the links to the project 
> page to a link to the report it generates. Besides, all my timing tags 
> vanished. The latter was particularly surprising for me, as these time 
> tags are just the beginning of a task description.
>
> Is this intended behaviour?

No, those are bugs.  I've never run into them, but I'll take a look.

> BTW: I used planner-multi.

That may be causing the problem with relinking the tasks on the
project pages.

I've run into some conceptual problems getting planner-multi and
planner-report to work together.  If a note has multiple tags, should
it appear more than once in the status report?  If not, under what
heading should it appear?

But I've found that for my purposes, planner-multi renders
planner-report obsolete.  I wrote planner-report so I could give my
boss a biweekly status report.  But with planner-multi, I can just tag
each task or note with "status" if I want it to appear there.  I have
some code (not very mature yet) to archive the status page every two
weeks, moving all the tasks and notes to a dated page of the form
status-YYYY.MM.DD.

=========


> If someone is familiar with both modes, feel free to suggest ways that
> they could complement one another.

By far my favorite featureset in org-mode that muse lacks is the table
support, which piggybacks on calc to form more of a spreadsheet than
table support. Insanely cool.

Only slightly off-topic, I have a few, probably not so serious
reservations about putting Markdown support into Muse. Markdown was
designed to be converted into (X)HTML only, and thus many little
decisions must have gone into the design of Markdown that, whilst
making transitions into HTML fantastic, probably provide some thorny
issues for integration with Muse. For example, <lisp> tags. Markdown
allows for valid XHTML tags, but throw in anything crazy like that and
it will cease to be a generic, parses-anywhere Markdown document. If
we're trying to serve those who use Markdown on a regular basis, and
ease their transition to Muse, it would be well for those we serve to
maintain integration with their other Markdown workflow. If they are
comfortable switching their workflow entirely, then I suppose this
isn't as much of an issue, but there are numerous (maybe even tens of)
tools that parse Markdown and would choke on a Muse/Markdown hybrid.

============


I don't understand why this is an issue.  If someone wants to preserve
compatibility with Markdown in their document, all they have to do is
use only Markdown-specific markup.  If there is a concern that someone
might unknowingly use Muse-specific markup, would it be sufficient to
just throw an optional warning message at them?

============


I have actually been thinking about an org-to-muse converter as a
possibility for easy expansion to many more export formats.  So I have
a number of ideas about what would be needed and where the
difficulties lie.  A short appetizer:

- Headline detection should be trivial, however
- Org-mode uses (at least: can use) many more levels than the 4
   available in Muse now.  The Org-mode exporters just switch to
   itemized lists at some headline level.
- Org-mode allows plain lists (itemize, bullet, numbered) of
   arbitrary depth and uses indentation to see the end of items.
   Muse, if I remember correctly, has one level of lists and is
   therefore very relaxed about indentation in lists
- Apart from plain lists, indentation is not syntactically significant
   in Org-mode, it is more visual sugar to make outline easily readable.
   Muse uses indentation for syntax, to quote text, for example.
- Links are similar, but not identical.
- Org-mode table lines also start with "|".  Table headlines are
   implicit, before the first horizontal line in the table.  No
   footer lines.
- etc.....

============


> Besides the obvious interaction, using the Muse engine to produce
> other export formats, can you think of more ways to interact?

Organization of work into publishable projects comes to mind.

One nice feature of Muse is that you can specify the major mode to
call on files inside of a project.

============

Date: Sun, 30 Apr 2006 23:01:17 +0200
============


You can use planner-multi.el to associate a task with more than one project.
That way, you can easily keep GTD-style context lists as well as
project-related lists.

To use multiple projects, add the following to your `~/.emacs':

     (require 'planner-multi)

Under GNU Emacs, you can specify multiple projects by separating them with a
single space. For example, you can specify planner doc when creating a task to
associate the task with those two projects.

Under XEmacs, you can specify multiple projects by typing RET after each entry
and terminating the list with another RET. For example, to specify planner and
doc, you would type planner RET doc RET RET at the prompt.

If you want to see an overview of all of your tasks as well as project- or
context-specific lists, you can set planner-multi-copy-tasks-to-page to your
overview page(s). For example, set it to `TaskPool' to be able to see an
overview of all of your unfinished tasks. You can also set this to multiple
pages such as `[[TasksByProject][p]] [[TasksByContext][c]]' and use
planner-trunk.el to sort and organize tasks for easy reference. (see Grouping
Tasks)
— User Option: planner-multi-copy-tasks-to-page

    Automatically copy newly-created tasks to the specified page.
   
By default, tasks are removed from planner-multi-copy-tasks-to-page when you
call planner-task-done or planner-task-cancelled. If you prefer to keep a copy
of the task, remove planner-multi-remove-task-from-pool from
planner-mark-task-hook.
 
=========

6.2.2.7 Grouping Tasks with planner-trunk.el

planner-trunk.el helps you automatically group tasks according to a set of
rules. It sorts and splits your tasks, adding a blank line between groups of
tasks. For example, if today's page looks like this:

     * Tasks
     
     #B   _ Buy milk (GroceryShopping)
     #B   _ Learn how to use planner-trunk (PlannerMode)
     #B   _ Buy a notebook (Bookstore)
     #B   _ Buy cereal (GroceryShopping)
     #B   _ Set up my own planner-trunk rules (PlannerMode)
     #B   _ Customize my stylesheet (MuseMode)
     #B   _ Go for a health checkup (BetterHealth)

then you might want to group the tasks into: planner and muse, shopping list,
and other items. If you set up the appropriate rules by customizing
planner-trunk-rule-list, planner-trunk.el can automatically rewrite that
section line this:

     * Tasks
     
     #B   _ Learn how to use planner-trunk (PlannerMode)
     #B   _ Set up my own planner-trunk rules (PlannerMode)
     #B   _ Customize my stylesheet (MuseMode)
     
     #B   _ Buy milk (GroceryShopping)
     #B   _ Buy a notebook (BookstoreShopping)
     #B   _ Buy cereal (GroceryShopping)
     
     #B   _ Go for a health checkup

In this case, you would set planner-trunk-rule-list to (("." nil ("PlannerMode\
\|MuseMode" "Shopping"))).

You can load planner-trunk with M-x load-library RET planner-trunk RET or add
(require 'planner-trunk). If you're not yet comfortable with Emacs Lisp, you
can use M-x customize-variable RET planner-trunk-rule-list RET to edit this
rule using an easy-to-use interface.

WARNING: Do not keep non-task information in the Tasks section. planner-trunk
will delete all non-task lines from the Tasks section of your plan page in the
process of grouping the tasks.

After you set up planner-trunk-rule-list, use M-x planner-trunk-tasks to try
out your rules until you're satistfied.

If you want to do this automatically, you can use (add-hook 'planner-mode-hook
'planner-trunk-tasks) to trigger it automatically whenever you open a Planner
page.

==============

— User Option: planner-annotation-strip-directory

    File links are usually generated with the full path to the file so that you
    can easily tell apart files with the same base name. If
    planner-annotation-strip-directory is non-nil, though, only the base name
    of the file will be displayed. For example, a link to `/foo/bar/baz' will
    be displayed as `baz' and hyperlinked to the file.
   
— User Option: planner-annotation-use-relative-file

    If t, always use relative filenames. planner-annotation-use-relative-file
    can also be a function that takes the filename and returns non-nil if the
    link should be relative. Filenames are resolved relative to the first
    directory of your Planner project in muse-project-alist. That is, the
    created link will be of the form `../../somefile' instead of `/absolute/
    path/to/file'. This can be helpful if you publish your planner files to the
    Net and your directory structure ensures that relative links resolve the
    same from your Plan pages and their respective publishing directory.

============
Thanks to the efforts of Jim Ottaway and Per B. Sederberg, the
development version of Muse should finally have the same level of
support for backlinks that emacs-wiki did.

To cause backlinks to be generated, follow the instructions in
muse-backlink.el.  To search for backlinks, run C-c C-b (or M-x
muse-find-backlinks).

If you encounter any errors or unexpected behavior, please report them
to the list so that they can be fixed before the 3.03 release of Muse
(which is scheduled tentatively for the end of March)
============

>> On 2006-03-22, Michael Olson <mwolson@gnu.org> wrote:
> My guess is that you have (:base "html" ..) instead of
> (:base "planner-html") in your muse-project-alist.  I can't tell for
> certain, since you didn't include your Planner and Muse settings.
oh, sorry... here is the snippet from my main.el I believe you refer to:
---------
(setq planner-directory "~/Plans")

(setq planner-project "WikiPlanner")

(setq muse-project-alist
       '(("WikiPlanner"
                ("~/Plans"
                 :default "TaskPool" 
                 :major-mode planner-mode
                 :visit-link planner-visit-link)
                 (:base "planner-html" 
                        :path "~/public_html/Plans"))))

(load "modes.el")
(load "hooks.el")
============

>> Following the pattern in examples/mwolson/muse-init.el for the
  >> "Blog" project, I am able to create a project with
  >> subdirectories.  When publishing to html, subdirectories are
  >> created in the target path corresponding to the subdirectories in
  >> the project, and muse files are rendered into html in the
  >> expected locations.  This part is working as I expect.
  >> 
  >> But how do I refer to a file in a different subdirectory in my
  >> project?

  R> I like your post.  I tried exactly the same alternatives myself
  R> and did not figure out how to handle subdirectories.

  R> Since your post and Mike's bug report #4702, are there any
  R> solutions available to these problems?


This doesn't do what you directly what you want; it does, however,
address a related problem and, indeed, I use it for subdirectories. 

It defines a new url type, which is like the interwiki support of
muse-wiki. You can also publish to a different directory structure
from the file space (which I do for historical reasons). So a link
like

[[iw:home\emacs][hello]] will work from any of the individual muse
projects that I have. 

Hope this is of some use. 

Phil

(add-to-list 'muse-url-protocols
             '("iw:" phil-muse-browse-url-iw phil-muse-resolve-url-iw))

(setq phil-muse-interwiki-protocol-alist
      '(("home" "/" "~/src/ht/home_website")
        ("silly" "/silly/" "~/src/ht/home_website/silly")
        ("energy" "/energy/" "~/src/ht/home_website/energy")
        ("journal" "/journal/" "~/src/ht/home_website/journal")))
     
     
(defun phil-muse-resolve-url-iw (url)
  (when (string-match "\\`iw:\\([a-zA-Z]*\\)\\\\\\(.+\\)" url)
    (let* ((wiki-resolve 
            (assoc (match-string 1 url)
                   phil-muse-interwiki-protocol-alist))
           (publish-resolve
            (nth 1 wiki-resolve)))
      (concat publish-resolve (match-string 2 url)))))
     
;; this doesn't handle anchors properly yet. 
(defun phil-muse-browse-url-iw (url)
  (when (string-match "\\`iw:\\([a-zA-Z]*\\)\\\\\\(.+\\)#?\\(.*\\)" url)
    (let* ((wiki-resolve 
            (assoc (match-string 1 url)
                   phil-muse-interwiki-protocol-alist))
           (browse-resolve
            (or (nth 2 wiki-resolve)
                (nth 1 wiki-resolve))))
      (find-file 
       (concat browse-resolve "/"
               (match-string 2 url)
               ".muse")))))
============

Remember writes a copy of the notes only to today's page.

But Sacha wrote the function planner-timewarp, which you can use to change
the date.  It tricks planner (and remember) into thinking that today is
another date.  I use it for the same purpose you would use it for -- to put
notes on different day pages.
============

>  3. have a function with a name like 'M-x link' that would create a
>     backlink to the current buffer, e-mail or bbdb record, and that
>     would save that link either to the kill ring or to a special
>     buffer (*back-links* for example). If it is saved to the kill ring,
>     it would then be easy to get it back, and if it is a special buffer
>     there would be another function to get back numerous links from that
>     buffer.

I think M-x planner-annotation-as-kill is what you're looking for.
That will put a link to the current buffer in the kill ring.
============

> When I do either 'M' or 'S' in calendar I get
> really wrong lunar and solar data. Is there
> something really wrong with what I have in my
> dotemacs:
> 
> (setq calendar-latitude 40.7)
> (setq calendar-longitude -73.9)
> (setq calendar-location-name "New York, NY")
> (setq calendar-time-zone -500)
> (setq calendar-standard-time-zone-name "EST")
> (setq calendar-daylight-time-zone-name "EDT")
> 
> and yes indeed, I live in Manhattan.


C-h v calendar-time-zone tells me this:


    calendar-time-zone's value is -420

    Documentation:
    *Number of minutes difference between local standard time at
    `calendar-location-name' and Coordinated Universal (Greenwich) Time.  For
    example, -300 for New York City, -480 for Los Angeles.

    Defined in `cal-dst'.

=============

>   I use planner-multi to allow me to have multiple links off a
>   particular planner item. Right now, if I want to add a new link to an
>   existing item, I call planner-replan-task, replicate the existing list
>   (using tab completion) and then add the new elements.

Does planner-multi-xref-task help?

C-u M-x planner-replan-task might also help. It picks up the current list.

==============

> > (global-set-key (kbd "<f8> e")  'planner-replan-task)
> >
> >   and I instead want F8-e to call planner-replan-task with a prefix
> >   argument, what do I need to change the binding to? (I've looked at the
> >   Emacs documentation, but can't seem to find the proper incantation...)
>
> How about `C-u <prefix> <f8> e'?

I had a similar problem with grep.  I wanted to bind a key to what
"C-u M-x grep" does.  Here is what I ended up using, thanks to the
kind folks on #emacs.

(defun grep-current-word ()
  "Grep for the current word"
  (interactive)
  (let ((current-prefix-arg t))
    (call-interactively 'grep)))

So something like (untested):

(defun planner-replan-task-with-edit ()
  "Call planner-replan-task with a prefix argument"
  (interactive)
  (let ((current-prefix-arg t))
    (call-interactively 'planner-replan-task)))

==============

	
	I just wanted to say that in order to keep track of my public and private
appointments and tasks, I'd been using spd.el for several weeks now and I think
it is great.  According to me, it is a much simpler alternative to
planner-authz.el for dealing with private appointments/tasks/schedules/etc.

Since the version on http://www.emacswiki.org/cgi-bin/wiki/PlannerModeContrib is
outdated (intended for emacs-wiki) one should use the one provided by Sven
Kloppenburg (muse under planner-mode), which is available at
http://thread.gmane.org/gmane.emacs.wiki.general/4654 (post dated December 9, 2005)

The only configuration needed consists in providing the muse project name (the
one that appear in muse-project-alist) for your public and private planners:

(setq spd-planner-work-directory "MyPublicPlanner" ; 
      spd-planner-personal-directory "MyPrivatePlanner"
      spd-save-buffers-before-kill t)

Then the command "M-x select-planner-project" lets you use your public planner,
whereas "C-u M-x select-planner-project" lets you use your private planner.

Thanks Raymond Zeitler and Sven Kloppenburg.
I wonder whether Select Planner Directory (spd.el) could be bundled along with
the planner-el Debian package?

==================

		 
> I would like to have appointment announcements (by means of a beep).  But this
> does not seem to work with planner-cyclic-diary nor with appointments directly
> stored in a plain "* Schedule" section.  Is it a matter of configuration or does
> that mean that such feature only works with planner-diary?

Yes, this works for me via planner-appt.  I use a CVS Emacs on OS X
from a few months ago.  It should be enough to have
(planner-appt-insinuate) in your config.

> Is it possible to have just one "* Schedule" section and no "* Diary" section
> and put all relevant diary entries into the "* Schedule" section?
>
> I cannot manage to do that.  Every time I try to do so my diary entries erase
> the other entries I had previously stored in the "* Schedule" section.  I don't
> want these lines to disappear.  How can I do?

I'm not sure because I'm not using planner-diary at all.  What is the
advantage of using both task-based appts and diary based one?  The
only ones I can think of have to do with birthday reminders and
floating appts which are all covered by planner-cyclic which does
integrate into planner-appt.



==============

> How about the case where one want to publish several files
> separately in HTML but combine them into a single PDF file?

Check out muse-book.el, examples/johnw/muse-johnw.el (for an example
configuration), and the Book node in the Muse manual.

==============

Michael  (Li, not Olson) --

Alternatively, try mmm-mode -- I've been looking at that for the next
variant of Sweave editing (muse x ESS x SLIME), though the idea holds
true for muse + html as well.

==============

Incidentally, would there be any interest in my ".ht" publishing style.
It's quite small, and I expect that the number of people in the world
insane enough to use both muse and ht2html (another excellent package)
will be quite small....

==============

http://ht2html.sourceforge.net

It's basically a python "style sheet" engine. The obvious thing to
do, of course, we be to re-write the end functionality directly
into a muse publishing engine, but I haven't really got time
to do that at the moment. It's basically just a small extension to 
the html mode.

==============

>>I'd be interesting in seeing your ".ht" publishing style too.
>>
> 
> 
> 
> It's attached. I've also included a small hack that I wrote last
> night which implements nested lists for muse. It only works on 
> unordered lists at the moment, and only for html (or derived)
> styles. 
> 
> Phil
> 
> 

Cool, thx.

Btw, for nested lists I currently do this:

  - Beatles
    <ul>
    - Yesterday
    - Revolution
    - Come Together
    </ul>

  - Who
    <ul>
    - The Real Me
    - Pure and Easy
    - Bargain
    </ul>

  - Police
    <ul>
    - Secret Journey
    - Too Much Information
    </ul>

Works pretty good, except only for publishing to html.

Also, I find it handy to nest examples within unordered lists like this:

  - C
    <example>
    #include <stdio.h>
    main() {
      printf( "Hello, world.\n" );
    }
    </example>

  - Java
    <example>
    static public void main(String[] args) {
      System.out.println("Hello, world.");
    }
    </example>

  - Ruby
    <example>
    puts "Hello, world."
    </example>

I have a little hack (from the mailing list) that removes the leading
indent from the examples.

Only thing is: a blank line within the example will terminate the
list item.  So, if I need a blank line within an example I put a
<nop> on it.

==============

I do what you do with tasks, associating descriptive text to them in the
form of Notes.  Since Planner puts a link to the note in the task, the
note's location isn't too important to me.  But here's where I do something
that you might want to try:

I create the note in the plan page using planner-create-note-from-task.  I
then delete the note number (.#1, for example) from the front of the note's
title.  Then I mark the note and invoke C-u M-x remember, which enables me
to copy the note to the day page and as many plan pages as I want.  (I also
use planner-multi.el, which enables me to put these notes on multiple plan
pages).

So all I use planner-create-note-from-task for is to create a hyperlink to a
note in the task item.  Then I use remember to create the note itself.  The
result is that my notes go into day pages and the appropriate plan page(s).

This is a thoroughly bizarre way to operate, but it works for me.

==============

> One of the things I like about using Planner is that it gets me into
> the habit of, at the beginning of the day, deciding what I'm going to
> do and, at the end of the day, evaluating whether or not I achieved my
> goals.  I'd like to do this same thing at the week level, the month
> level, the quarter level, and the year level.  This way each time
> period breaks down into 3-4 smaller time periods, and I can keep an
> eye on larger, longer-term goals.  (I've posted one or two messages
> about this before).
>
> To this end, I've put together a little code that lets you skip around
> on pages that correspond to the different time intervals.  When I'm
> looking at how I did over the past month, I want an easy way to look
> at how I did for the weeks of that month.  Typing out all the page
> names is tedious and time consuming, so I've created four functions
> zoom-iup (for interactive-up), zoom-idown, zoom-inext, and zoom-iprev
> (which I bind to Shift-up, Shift-down, etc).  
>
> The naming convention for pages is:
> year - "2006.Year"
> quarter - "2006.Quarter2"
> month - "2006.January"
> week - "2006.January.Week3"
> day - "2006.01.02"  
> (this can be changed by changing zoom-regexps)
>
> So typically I would look at the page named "2006.January" and then
> hit 'C-u S-down' which shows me 2006.January.Week1 in the other
> buffer.  Then I can hit S-left and S-right to look at
> 2006.January.Week2, 2006.January.Week3, etc.  
>
> I determine the month to which each week belongs by the month which
> contains the zoom-first-day-of-week'th day of that week.  Zero is
> Sunday, one is Monday, etc.  Therefore the March 1, 2006, would
> typically be fall into "2006.February.Week4"
>
> I'd like to be able to carry week-level tasks forward to the next
> week, but I haven't worked on that yet.  
>
> So, enjoy.  Comments welcome.
>
> Greg
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Config
> (defvar zoom-first-day-of-week 1 "What day should be considered the first of the week.  Zero for Sunday, one for Monday, etc")
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Guts
> (defvar zoom-months '(("January" . 1)
> 		      ("February" . 2)
> 		      ("March" . 3)
> 		      ("April" . 4)
> 		      ("May" . 5)
> 		      ("June" . 6)
> 		      ("July" . 7)
> 		      ("August" . 8)
> 		      ("September" . 9)
> 		      ("October" . 10)
> 		      ("November" . 11)
> 		      ("December" . 12)
> 		      ("Month" . 13)) ; Extra invalid value
>   "Alist associating month names with numbers.")
>
> (defvar zoom-month-regexp (concat "\\(" 
> 				  (reduce (lambda (x y) (concat x "\\|" y)) 
> 					  (mapcar 'car zoom-months)) 
> 				  "\\)")
>   "Regexp matching any month name given in zoom-months")
>
> (defvar zoom-regexps (list '("^\\([0-9]\\{4\\}\\).Year$" 
> 			     . year) ; (year)
> 			   '("^\\([0-9]\\{4\\}\\).Quarter\\([0-5]\\)$" 
> 			     . quarter) ; (year, quarter)
> 			   (cons (concat "^\\([0-9]\\{4\\}\\)."
> 					 zoom-month-regexp
> 					 "$") 
> 				 'month) ; (year, month)
> 			   (cons (concat "^\\([0-9]\\{4\\}\\)."
> 				       zoom-month-regexp
> 				       ".Week\\([0-6]\\)$")
> 				 'week); year, month, week
> 			   '("^\\([0-9]\\{4\\}\\).\\([0-9]\\{1,2\\}\\).\\([0-9]\\{1,2\\}\\)$" 
> 			     . day)) ; year, month, day
>   "Alist of regexps that match names of years, quarters, months,
>   weeks, and days")
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Heavy lifting functions
> (defun zoom-parse-to-strings (name &optional type)
>   "Parse a string NAME, into a period of time given by zoom-regexps.  
>
>   If TYPE is given, it is a symbol specifying the
>   type of time-period which NAME should be parsed as (one of
>   'day, 'week, 'month, 'quarter, or 'year.
>
>   Return a four element list consisting of the type of time
>   period and then a list of strings containing the subexpressions
>   matched by the successful regexp.  Eg, 
>   (zoom-parse-to-strings \"2006.Year\") 
>   returns (year \"2006\" nil nil) 
>   and (zoom-parse-to-strings \"2006.January.Week1\") 
>   returns (week \"2006\" \"January\" \"1\")"
>   (setq type (or type (assoc-default name zoom-regexps 'string-match)))  
>   ;; Make sure the match data is for the right search
>   (unless (string-match (car (rassoc type zoom-regexps)) name)
>     (error "Zoom: Couldn't Parse Name"))
>   (cons type (list (match-string 1 name) 
> 		   (match-string 2 name) 
> 		   (match-string 3 name))))
>
> (defun zoom-parse (&rest args)
>   "Parse a string NAME, into a period of time given by zoom-regexps.  
>
>   If TYPE is given, it is a symbol specifying the
>   type of time-period which NAME should be parsed as (one of
>   'day, 'week, 'month, 'quarter, or 'year.
>
>   Return a four element list consisting of the type of time
>   period and then numerical representations of the subexpressions
>   matched by the successful regexp.  Eg, 
>   (zoom-parse \"2006.Year\") returns (year 2006 nil nil)
>   and (zoom-parse \"2006.January.Week1\") returns (week 2006 1 1)" 
>
>   (let* ((result (apply 'zoom-parse-to-strings args))
> 	 (type (car result))
> 	 (strings (cdr result))
> 	 numbers)
>     (dotimes (i (length strings))
>       (setq numbers (cons (when (not (null (nth i strings)))
> 			    (if (or (and (eq type 'month) (= i 1))
> 				    (and (eq type 'week) (= i 1)))
> 				(cdr (assoc (nth i strings) zoom-months))
> 			      (string-to-number (nth i strings))))
> 			  numbers)))
>     (cons type (reverse numbers))))
>
> (defun zoom-string (type &rest changes)
>   "Convert time-range info into a string name.  You can specify
>    numerical values or strings.  So
>   (zoom-string 'year 2006) -> \"2006.Year\"
>   (zoom-string 'year \"2006\") -> \"2006.Year\"
>   (zoom-string 'week 2006 \"February\" 3) -> \"2006.February.Week3\"
>   (zoom-string 'week 2006 2 3) -> \"2006.February.Week3\""
>   ;; use a template
>   (let ((name (cdr (assoc type '((year . "1000.Year")
> 				 (quarter . "1000.Quarter5")
> 				 (month . "1000.Month")
> 				 (week . "1000.Month.Week6")
> 				 (day . "1000.99.99"))))))
> 	
>     ;; Make sure changes are strings
>     (let (result)
>       (dotimes (i (length changes))
> 	(setq result (cons (if (not (numberp (nth i changes)))
> 			       (nth i changes)
> 			       (if (or (and (eq type 'month) (= i 1))
> 				       (and (eq type 'week) (= i 1)))
> 				   (car (rassoc (nth 1 changes) zoom-months))
> 				   (number-to-string (nth i changes))))
> 			   result)))
>       (setq changes (reverse result)))
>     
>     ;; Special handling for days + months in 'day strings: make sure
>     ;; they're two digits
>     (when (eq type 'day)
>       (setq changes (mapcar (lambda (x) (if (= (length x) 1) 
> 					    (concat "0" x)
> 					    x))
> 			    changes)))
>     
>     (dotimes (i (length changes))
>       (zoom-parse name type)    ; make sure match data is correct each time
>       (setq name (replace-match (nth i changes) t t name (1+ i))))
>     name))
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Interactive
>
> (add-hook 'planner-mode-hook (lambda ()
> 			       (local-set-key (kbd "<S-up>") 'zoom-iup)
> 			       (local-set-key (kbd "<S-down>") 'zoom-idown)
> 			       (local-set-key (kbd "<S-left>") 'zoom-iprev)
> 			       (local-set-key (kbd "<S-right>") 'zoom-inext)))
>
> (defun zoom-iup (name other-window) 
>   "Move to the next higher level in the hierarchy."
>   (interactive (list (buffer-name)
> 		    current-prefix-arg))
>   (when other-window (other-window 1))
>   (emacs-wiki-find-file (zoom-up name))
>   (when other-window (other-window 1)))
>
> (defun zoom-idown (name other-window) 
>   "Move to the next lower level in the hierarchy.  If the current
>   date is within the higher-level time range, zoom to the lower
>   level time range that also contains today.  Otherwise, just go
>   to the first lower-level time range."
>   (interactive (list (buffer-name)
> 		     current-prefix-arg))
>   (when other-window (other-window 1))
>   (emacs-wiki-find-file (zoom-down name))
>   (when other-window (other-window 1)))
>
> (defun zoom-inext (name num other-window)
>   "Move to the next time range at the same level in the
>   hierarchy.  With a numeric prefix arg, move by that number of
>   time ranges.  With a non-numeric prefix arg, show the desired
>   page in the other window."
>   (interactive (list (buffer-name)
> 		     (if (numberp current-prefix-arg) 
> 			 current-prefix-arg
> 		       1)
> 		     (consp current-prefix-arg)))
>   (when other-window (other-window 1))
>   (emacs-wiki-find-file (zoom-next name num))
>   (when other-window (other-window 1)))
>
> (defun zoom-iprev (name num other-window)
>   "Move to the previous time range at the same level in the
>   hierarchy.  With a numeric prefix arg, move by that number of
>   time ranges.  With a non-numeric prefix arg, show the desired
>   page in the other window."
>   (interactive (list (buffer-name)
> 		     (if (numberp current-prefix-arg) 
> 			 current-prefix-arg
> 		       1)
> 		     (consp current-prefix-arg)))
>   (when other-window (other-window 1))
>   (emacs-wiki-find-file (zoom-next name (- num)))
>   (when other-window (other-window 1)))
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Non-period-specific stuff
> (defun zoom-contains (name &optional today)
>   "Test if TODAY is contained within the time period specified by
>   string NAME.  If TODAY is not given, use the current date"
>   (setq today (or today (gsn/calendar-today-absolute)))
>   (and (<= (zoom-beg name) today)
>        (>= (zoom-end name) today)))
>
> (defun zoom-beg (name)
>   "Return the absolute date of the beginning of the time period
>   specified by string NAME."
>   (funcall 
>    ;; This is basically do-it-yourself object orientation.  Times are
>    ;; lists where the first element is the type and the other elements
>    ;; are type-specific information.  This function call dispatches on
>    ;; the type, so it's basically a method call on a time range.
>    (cdr (assoc (car (zoom-parse name)) '((year . zoom-year-beg)
> 					 (quarter . zoom-quarter-beg)
> 					 (month . zoom-month-beg)
> 					 (week . zoom-week-beg)
> 					 (day . zoom-day-beg))))
>    name))
>
> (defun zoom-end (name)
>   "Return the absolute date of the end of the time period
>   specified by string NAME."
>   (funcall 
>    ;; See zoom-beg comments
>    (cdr (assoc (car (zoom-parse name)) '((year . zoom-year-end)
> 					 (quarter . zoom-quarter-end)
> 					 (month . zoom-month-end)
> 					 (week . zoom-week-end)
> 					 (day . zoom-day-end))))
>    name))
>
> (defun zoom-up (name)
>   "For time range given by string NAME, return a string
>   representiang the next higher enclosing time range in the
>   heirarchy"
>   (funcall 
>    ;; See zoom-beg comments
>    (cdr (assoc (car (zoom-parse name)) '((year . zoom-up-year)
> 					 (quarter . zoom-up-quarter)
> 					 (month . zoom-up-month)
> 					 (week . zoom-up-week)
> 					 (day . zoom-up-day))))
>    name))
>
> (defun zoom-down (name)
>   "For time range given by string NAME, return a string
>   representiang the next lower time range in the heirarchy.  If
>   the current date is within the higher-level time range, choose
>   the lower-level time range that also includes the current date.
>   Otherwise, just retturn the first lower-level time range"
>   (funcall 
>    ;; See zoom-beg comments
>    (cdr (assoc (car (zoom-parse name)) '((year . zoom-down-year)
> 					 (quarter . zoom-down-quarter)
> 					 (month . zoom-down-month)
> 					 (week . zoom-down-week)
> 					 (day . zoom-down-day))))
>    name))
>
> (defun zoom-next (name num)
>   "For time range given by string NAME, return a string
>   representiang the next time range at the same level in the heirarchy."
>   (funcall 
>    ;; See zoom-beg comments
>    (cdr (assoc (car (zoom-parse name)) '((year . zoom-next-year)
> 					 (quarter . zoom-next-quarter)
> 					 (month . zoom-next-month)
> 					 (week . zoom-next-week)
> 					 (day . zoom-next-day))))
>    name num))
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Year
> (defun zoom-year-beg (name)
>   "Return the absolute date of the beginning of the year
>   specified by string NAME"
>   (multiple-value-bind (type year) (zoom-parse name 'year)
>     (calendar-absolute-from-gregorian (list 1 1 year))))
>
> (defun zoom-year-end (name)
>   "Return the absolute date of the end of the year
>   specified by string NAME"
>   (multiple-value-bind (type year) (zoom-parse name 'year)
>     (calendar-absolute-from-gregorian (list 12 31 year))))
>
> (defun zoom-up-year (name) 
>   "Error: there's nothing above year in the heirarchy"
>   nil)
>
> (defun zoom-next-year (name num)
>   "Return a string NUM years after the one given by string NAME."
>   (multiple-value-bind (type year) (zoom-parse name 'year)
>     (zoom-string 'year (+ num year))))
>
> (defun zoom-down-year (name &optional today)
>   "If the absolute date TODAY is within the year specified by
>   NAME, return a string for the quarter that also contains TODAY.
>   Otherwise, return the a string for the first quarter in the
>   year.  If TODAY is not given, use the current date."
>   (multiple-value-bind (junk year) (zoom-parse name 'year)
>     (if (not (zoom-contains name today)) 
> 	(zoom-string 'quarter year 1)
>       (car (remove-if-not (lambda (p) (zoom-contains p today))
> 			  (mapcar (lambda (n) (zoom-string 'quarter year n))
> 				  (range 1 4)))))))
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Quarter
> (defun zoom-up-quarter (name)
>   "Return a string for the year containing the quarter specified
>   by string NAME."
>   (multiple-value-bind (type year quarter) (zoom-parse name 'quarter)
>     (zoom-string 'year year)))
>
> (defun zoom-quarter-beg (name)
>   "Return the absolute date of the first day of the quarter given
>   by string NAME"
>   (multiple-value-bind (type year quarter) (zoom-parse name 'quarter)
>     (calendar-absolute-from-gregorian (list (1+ (* 3 (1- quarter))) 1 year))))
>
> (defun zoom-quarter-end (name)
>   "Return the absolute date of the last day of the quarter given
>   by string NAME"
>   (multiple-value-bind (type year quarter) (zoom-parse name 'quarter)
>     (cond ((= 1 quarter) (calendar-absolute-from-gregorian (list 3 31 year)))
> 	  ((= 2 quarter) (calendar-absolute-from-gregorian (list 6 30 year)))
> 	  ((= 3 quarter) (calendar-absolute-from-gregorian (list 9 30 year)))
> 	  ((= 4 quarter) (calendar-absolute-from-gregorian (list 12 31 year))))))
>
> (defun zoom-next-quarter (name num)
>   "Return a string for the name of the NUMth quarter after the
>   one given by string NAME."
>   (multiple-value-bind (type year quarter) (zoom-parse name 'quarter)  
>     (let ((new-year (+ year (floor (/ (1- (float (+ quarter num))) 4))))
> 	  (new-quarter (1+ (mod (1- (+ quarter num)) 4))))
>       (zoom-string 'quarter new-year new-quarter))))
>
> (defun zoom-down-quarter (name &optional today)
>   "If the absolute TODAY is within the quarter given by string
>   NAME, return a string for the month that also contains TODAY.
>   Otherwise, return a string for the first month in the
>   quarter.  If TODAY is not given, use the current date."
>   (multiple-value-bind (type year quarter) (zoom-parse name 'quarter) 
>     (if (not (zoom-contains name today)) 
> 	(zoom-string 'month year (1+ (* (1- quarter) 3)))
> 	;; inefficient, but correct, to just include all months in the
> 	;; test since we know that the current quarter contains today,
> 	;; therefore some month in another quarter _cannot_ contain
> 	;; today
>       (car (remove-if-not (lambda (p) (zoom-contains p today)) 
> 			  (mapcar (lambda (n) (zoom-string 'month year n))
> 				  (range 1 12)))))))
>
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Month
>
> (defun zoom-month-beg (name)
>   "Return the absolute date of the first day of the month given
>   by the string NAME."
>   (multiple-value-bind (type year month) (zoom-parse name 'month)
>     (calendar-absolute-from-gregorian (list month 1 year))))
>
> (defun zoom-month-end (name)
>   "Return the absolute date of the last day of the month given
>   by the string NAME."
>   (multiple-value-bind (type year month) (zoom-parse name 'month)
>     (calendar-absolute-from-gregorian (list month (calendar-last-day-of-month month year) year))))
>
> (defun zoom-up-month (name)
>   "Return a string for the quarter containing the month given by string NAME."
>   (multiple-value-bind (type year month) (zoom-parse name)
>     (let ((quarter (1+ (/ (1- month) 3))))
>       (zoom-string 'quarter year quarter))))
> 	    	   
> (defun zoom-next-month (name num)
>   "Return a string for the NUMth month after the one given by the
>   string NAME"
>   (multiple-value-bind (type year month) (zoom-parse name 'month)
>     (let ((new-year (+ year (floor (/ (1- (float (+ month num))) 12))))
> 	  (new-month (1+ (mod (1- (+ month num)) 12))))
>       (zoom-string 'month new-year new-month))))
>
> (defun zoom-down-month (name &optional today)
>   "If the absolute date TODAY is within the month given by the
>   string NAME, return a string for the week that also contains
>   TODAY.  Otherwise, return a string for the first week in the
>   month.  If TODAY is not given, use the current date."
>   (multiple-value-bind (type year month) (zoom-parse name 'month)  
>     (if (not (zoom-contains name today)) 
> 	(zoom-string 'week year month 1)
>       (car (remove-if-not (lambda (p) (zoom-contains p today))
> 			  (mapcar (lambda (n) (zoom-string 'week year month n))
> 				  (range 1 5)))))))
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Week
>
> (defun zoom-week-beg (name)
>   "Return the absolute date of the first day of the week given by string NAME."
>   (multiple-value-bind (type year month week) (zoom-parse name 'week)
>     (calendar-absolute-from-gregorian 
>      (calendar-nth-named-day week zoom-first-day-of-week month year))))
>
> (defun zoom-week-end (name)
>   "Return the absolute date of the last day of the week given by string NAME."
>   (+ 6 (zoom-week-beg name)))
>
> (defun zoom-up-week (name)
>   "Return a string for the month containing the week given by string NAME."
>   (multiple-value-bind (type year month week) (zoom-parse name 'week)
>     (zoom-string 'month year month)))
>
> (defun zoom-next-week (name num)
>   "Return a string for the NUMth week after the one specified by
>   the string NAME."
>   (multiple-value-bind (type year month week) (zoom-parse name 'week)
>     ;; New week <= 0 leads to problems with nth-named-day... try to fix them?
>     (let* ((new-week (if (> (+ week num) 0) 
> 			 (+ week num)
> 		       (1- (+ week num))))
> 	   (new-date (calendar-nth-named-day new-week zoom-first-day-of-week month year 1))
> 	   (new-year (extract-calendar-year new-date))
> 	   (new-month (extract-calendar-month new-date))
> 	   (new-day (extract-calendar-day new-date))	   
> 	   (first-date (calendar-nth-named-day 1 zoom-first-day-of-week new-month new-year 1))
> 	   (first-day (extract-calendar-day first-date))
> 	   (new-week (1+ (/ (- new-day first-day) 7))))
>       (zoom-string 'week new-year new-month new-week))))
>
> (defun zoom-down-week (name &optional today)
>   "If the absolute date TODAY is within the week specified by
>   string NAME, return a string for TODAY.  Otherwise, return the
>   first day in the week.  If TODAY is not given, use the current date."
>   (setq today (or today (gsn/calendar-today-absolute)))
>   (multiple-value-bind (type year month week) (zoom-parse name 'week)
>     (if (not (zoom-contains name today)) 	
> 	(zoom-string 'day year month 
> 		     (extract-calendar-day 
> 		      (calendar-nth-named-day week zoom-first-day-of-week month year)))
>       (let* ((today (calendar-gregorian-from-absolute today))
> 	     (year (extract-calendar-year today))
> 	     (month (extract-calendar-month today))
> 	     (day (extract-calendar-day today)))
> 	(zoom-string 'day year month day)))))
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> ;; Day
>
> (defun zoom-day-beg (name)
>   "Return the absolute date of the day given by the string NAME."
>   (multiple-value-bind (type year month day) (zoom-parse name 'day)
>     (calendar-absolute-from-gregorian (list month day year))))
>
> (defun zoom-day-end (name)
>   "Return the absolute date of the day given by the string NAME."
>   (zoom-day-beg name))
>
> (defun zoom-up-day (name)
>   "Return a string for the week that contains the day given by
>   the string NAME."
>   (multiple-value-bind (type year month day) (zoom-parse name 'day)
>     (let* ((first-date (calendar-nth-named-day 1 zoom-first-day-of-week month year))
> 	   (first-day (extract-calendar-day first-date))
> 	   (week (1+ (/ (- day first-day) 7))))
>       (zoom-string 'week year month week))))
>
> (defun zoom-next-day (name num)
>   "Return the NUMth day after the one given by the string NAME."
>   (let ((new-date (calendar-gregorian-from-absolute (+ (zoom-day-beg name) num))))
>     (zoom-string 'day 
> 		 (extract-calendar-year new-date)
> 		 (extract-calendar-month new-date)
> 		 (extract-calendar-day new-date))))
>
> (defun zoom-down-day (name) 
>   nil)
>
> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> (defvar zoom-tests
>       '((zoom-parse-to-strings ("2006.Year")  (year "2006" nil nil))
> 	(zoom-parse-to-strings ("2006.January") (month "2006" "January" nil))
> 	(zoom-parse-to-strings ("2006.Quarter1") (quarter "2006" "1" nil))
> 	(zoom-parse-to-strings ("2006.January.Week1") (week "2006" "January" "1"))
> 	(zoom-parse-to-strings ("2006.01.03") (day "2006" "01" "03"))
> 	
> 	(zoom-parse ("2006.Year") (year 2006 nil nil))
> 	(zoom-parse ("2006.January") (month 2006 1 nil))
> 	(zoom-parse ("2006.Quarter1") (quarter 2006 1 nil))
> 	(zoom-parse ("2006.January.Week1") (week 2006 1 1))
> 	(zoom-parse ("2006.01.03") (day 2006 1 3))
> 	
> 	(zoom-string (year 2007) "2007.Year")
> 	(zoom-string (year "2007") "2007.Year")
> 	(zoom-string (quarter 2007 2) "2007.Quarter2")
> 	(zoom-string (quarter "2007" "2") "2007.Quarter2")
> 	(zoom-string (month 2007 2) "2007.February")
> 	(zoom-string (month "2007" "February") "2007.February")
> 	(zoom-string (week 2007 2 2) "2007.February.Week2")
> 	(zoom-string (week "2007" "February" "2") "2007.February.Week2")
> 	(zoom-string (day 2007 2 2) "2007.02.02")
> 	(zoom-string (day "2007" "2" "2") "2007.02.02")
> 	
> 	(zoom-contains ("2006.Year" 732311) nil)
> 	(zoom-contains ("2006.Year" 732312) t)
> 	(zoom-contains ("2006.Year" 732463) t)
> 	(zoom-contains ("2006.Year" 732676) t)
> 	(zoom-contains ("2006.Year" 732677) nil)
> 	
> 	(zoom-year-beg ("2006.Year") 732312)
> 	(zoom-quarter-beg ("2006.Quarter1") 732312)
> 	(zoom-quarter-beg ("2006.Quarter2") 732402)
> 	(zoom-quarter-beg ("2006.Quarter3") 732493)
> 	(zoom-quarter-beg ("2006.Quarter4") 732585)
> 	(zoom-month-beg ("2006.January") 732312)
> 	(zoom-week-beg ("2006.January.Week1") 732313)
> 	(zoom-week-beg ("2006.January.Week2") 732320)
> 	(zoom-week-beg ("2006.January.Week3") 732327)
> 	(zoom-week-beg ("2006.January.Week4") 732334)
> 	(zoom-week-beg ("2006.January.Week5") 732341)
> 	(zoom-week-beg ("2006.January.Week6") 732348)
> 	(zoom-day-beg ("2006.02.03") 732345)
> 	
> 	(zoom-year-end ("2006.Year") 732676)
> 	(zoom-quarter-end ("2006.Quarter1") 732401)
> 	(zoom-quarter-end ("2006.Quarter2") 732492)
> 	(zoom-quarter-end ("2006.Quarter3") 732584)
> 	(zoom-quarter-end ("2006.Quarter4") 732676)
> 	(zoom-month-end ("2006.January") 732342)
> 	(zoom-week-end ("2006.January.Week1") 732319)
> 	(zoom-week-end ("2006.January.Week2") 732326)
> 	(zoom-week-end ("2006.January.Week3") 732333)
> 	(zoom-week-end ("2006.January.Week4") 732340)
> 	(zoom-week-end ("2006.January.Week5") 732347)
> 	(zoom-week-end ("2006.January.Week6") 732354)
> 	(zoom-day-end ("2006.01.01")  732312)
> 	
> 	(zoom-next-year ("2006.Year" 2) "2008.Year")
> 	(zoom-next-year ("2006.Year" -2) "2004.Year")
> 	(zoom-next-year ("2006.Year" 0) "2006.Year")
> 	(zoom-next-quarter ("2006.Quarter2" 5) "2007.Quarter3")
> 	(zoom-next-quarter ("2006.Quarter2" -5) "2005.Quarter1")
> 	(zoom-next-quarter ("2006.Quarter2" 0) "2006.Quarter2")
> 	(zoom-next-month ("2006.June" 13) "2007.July")
> 	(zoom-next-month ("2006.June" -13) "2005.May")
> 	(zoom-next-month ("2006.June" 0) "2006.June")
> 	(zoom-next-week ("2006.April.Week2" 3) "2006.May.Week1")
> 	(zoom-next-week ("2006.April.Week2" -2) "2006.March.Week4")
> 	(zoom-next-week ("2006.April.Week2" 0) "2006.April.Week2")
> 	(zoom-next-day ("2006.04.03" -7) "2006.03.27")
> 	(zoom-next-day ("2006.04.03" -1) "2006.04.02")
> 	(zoom-next-day ("2006.04.03" 0) "2006.04.03")
> 	(zoom-next-day ("2006.04.03" 1) "2006.04.04")
> 	(zoom-next-day ("2006.04.03" 28) "2006.05.01")
> 	
> 	(zoom-up-quarter ("2006.Quarter1") "2006.Year")
> 	(zoom-up-month ("2006.April") "2006.Quarter2")
> 	(zoom-up-week ("2006.April.Week1") "2006.April")
> 	(zoom-up-day ("2006.04.10") "2006.April.Week2")
>
>  	;(calendar-absolute-from-gregorian (4 30 2006) 732431)
> 	;(calendar-absolute-from-gregorian (4 30 2005) 732066)
> 	
> 	;; April 30th, 2006: Should zoom down to Q2, Month 4, Week 4, day 4.30.2006
> 	(zoom-down-year ("2006.Year" 732431) "2006.Quarter2")
> 	(zoom-down-quarter ("2006.Quarter2" 732431) "2006.April")
> 	(zoom-down-month ("2006.April" 732431) "2006.April.Week4")
> 	(zoom-down-week ("2006.April.Week4" 732431) "2006.04.30")
> 	
> 	;; April 30th, 2005: Should zoom down to Q1, January, Week 1, 1.1.2006
> 	(zoom-down-year ("2006.Year" 732066) "2006.Quarter1")
> 	(zoom-down-quarter ("2006.Quarter1" 732066) "2006.January")
> 	(zoom-down-month ("2006.January" 732066) "2006.January.Week1")
> 	(zoom-down-week ("2006.January.Week1" 732066) "2006.01.02"))
>   "A list of lists of the form (function-name function-arguments
>   desired-result) which is used to test the functions in the zoom
>   package")
>
> (defun zoom-test ()
>   "Run all the tests in zoom-tests."
>   (dolist (test zoom-tests)
>     (let* ((fn (first test))
> 	   (fn-args (second test))
> 	   (desired-result (third test))
> 	   (result (apply fn fn-args)))
>       (when (not (equal desired-result result))
> 	(error "Failed test!"))))
>   t)
>   
>
>
> (defun gsn/calendar-today-gregorian ()
>   (multiple-value-bind (junk junk junk day month year) (decode-time)
>     (list month day year)))
>
> (defun gsn/calendar-today-absolute ()
>   (calendar-absolute-from-gregorian (gsn/calendar-today-gregorian)))

==============

It's been a while since I had this idea on my mind, but only now could I find
the time to make it real. I wanted to have a single set of calendar entries in
planner, Google calendar, my smartphone, etc. So, the easiest way, so far, is
to export my planner entries into an ical format. Initially I thought I would
use planner-icalendar.el, but this is not enough, as I use my today plan page
with all my tasks. What I need is my cyclic entries to appear on the calendar,
and my appointments made for a given day / hour - just like what I've
accomplished earlier with my hacks to weekly-view.

After having the export done, the only thing I'm lacking is a way to import an
ical. I don't want to import it to the main diary file, but to a temporary one,
so I can do a weekly-view, or see the calendar based on it - then discard it,
if I don't need it. It seems we're evolving towards multiple, possibly shared,
calendars, so I believe this should be on everyone's wishlist. Is anyone
handling this situation already? How?


So here's the code, you should set it up after having the mentioned hacks to
weekly-view, as I have redifined some functions. All you need then is to find a
good destination (e.g., a remote location), and call `planner-export-ical'. See
the thread at
http://www.archivum.info/emacs-wiki-discuss@nongnu.org/2006-03/msg00112.html
for details on the required adaptations.

;; iCalendar export of appointments:

(load "icalendar.el")

(defun planner-export-ical (category-regexp n ical-output-file)
  "Write ICAL-OUTPUT-FILE with iCalendar format. CATEGORY_REGEXP will
limit category marked entries, enabling filtering of the exported
data (up until N days from now).
The iCalendar exported data are all the planner task appointments and
all the cyclic diary entries (in `planner-cyclic-diary-file').
They are exported as VEVENTs."
  (interactive)
  ;; Get the appointments until end-date:
  (let ((appts (planner-appt-forthcoming-get-appts n (planner-today))))
    ;; And now add the cyclic appointments from the appropriate file:
    (with-temp-buffer
      (let ((cyclic-appts nil))
	(with-temp-buffer
	  (find-file planner-cyclic-diary-file)
	  (dolist (line (split-string (buffer-string) "[\n\r]"))
	    (unless (or (string= line "")
			(string-match "^!" line))
	      (push line cyclic-appts)))
	  (kill-buffer (current-buffer)))
	(dolist (appt-desc cyclic-appts)
	  (let ((appt-category (when (string-match "\\(.*\\)[ \t]*(\\(.*\\))$" appt-desc)
				 (match-string 2 appt-desc)))
		(appt-text (match-string 1 appt-desc)))
	    ;; Now filter by categories regexp:
	    (when (string-match category-regexp appt-category)
	      (when (string-match "\\(.*\\) @\\([0-2]?[0-9]:[0-5]?[0-9]\\)[ \t]*[-|][ \t]*\\([0-2]?[0-9]:[0-5]?[0-9]\\)[ \t]*|?[ \t]*\\(.*\\)$"
				  appt-text)
		(let ((day        (match-string 1 appt-text))
		      (start-time (match-string 2 appt-text))
		      (end-time   (match-string 3 appt-text))
		      (text       (match-string 4 appt-text)))
		  (setq appt-text (format "%s %s-%s %s\n" day start-time end-time text))
		  (message "Adding cyclic appt to temp diary:::: %s" appt-text)
		  (insert appt-text)))))))
      (dolist (appt appts)
	(let* ((appt-date (first appt))
	       (appt-desc (second appt))
	       (appt-category (when (string-match "\\(.*\\)(\\(.*\\))$" appt-desc)
				(match-string 2 appt-desc)))
	       (appt-text (when (string-match "\\(.*\\)\\((.*)\\)?$" appt-desc)
				(match-string 1 appt-desc))))
	  ;; Filter task appointments only:
	  (when (and appt-text
		     (string-match "\@?\\(.*\\)[ 	]*|?[ 	]#[	 ]*[-|]?\\(.*\\)$" appt-text)
		     ;; Now filter by categories regexp:
		     (or (null appt-category)
			 (save-match-data  (string-match category-regexp appt-category))))
	    ;; Extract time and text strings:
		(let ((appt-time (match-string 1 appt-text))
		      (appt-text (match-string 2 appt-text)))
		  (setq appt-time (replace-in-string appt-time "|" ""))
		  (setq appt-time (replace-in-string appt-time " [ ]*" " "))
		  (setq appt-time (replace-in-string appt-time " $" ""))
		  (setq appt-time (replace-in-string appt-time " " "-"))
		  (setq appt-date (apply #'format "%s/%s/%s" (planner-filename-to-calendar-date appt-date)))
		  (message "Adding task to temp diary:::: %s %s %s" appt-date appt-time appt-text)
		  (insert (format "%s %s %s\n" appt-date appt-time appt-text))))))
	(icalendar-export-region (point-min)
				 (point-max)
				 ical-output-file))))

;; icalendar fix (this function wouldn't work properly under my Windows + GNU
;; Emacs configuration, so I just removed a silly comparison:
(defalias 'icalendar--rris 'replace-regexp-in-string)


(defun planner-publish-ical (arg &optional destination)
  "Publish a calendar to DESTINATION (defaults to a local file, \"~/exported-planner-appts.ics\")."
  (interactive "p")
  (let ((destination (or destination
			 (if (= arg 0)
			     "~/exported-planner-appts.ics"
			     (concat personal-wiki-remote-publish-location "/exported-planner-appts.ics")))))
    (with-current-buffer (current-buffer)
      (find-file destination)
      (goto-char (point-min))
      (delete-matching-lines ".")
      (save-buffer))
    (planner-export-ical "." 20 destination)))




Cheers!

==============

The best way to create a new page is to use C-c C-f and type (for
example) MyNewPage.  This will create MyNewPage.muse, and then
[[MyNewPage]] will open that page instead of "MyNewPage".

==============

> Does anyone know of an alarm clock that runs in emacs?

There is now! :) See below:

(defvar alarm-clock-timer nil
  "Keep timer so that the user can cancel the alarm")

(defun alarm-clock-message (text)
  "The actual alarm action"
  (message-box text))

(defun alarm-clock ()
  "Set an alarm.
The time format is the same accepted by `run-at-time'.  For
example \"11:30am\"."
  (interactive)
  (let ((time (read-string "Time: "))
        (text (read-string "Alarm message: ")))
    (setq alarm-clock-timer (run-at-time time nil 'alarm-clock-message text))))

(defun alarm-clock-cancel ()
  "Cancel the alarm clock"
  (interactive)
  (cancel-timer alarm-clock-timer))

It is very simple. It does not, for example, keep track of multiple
alarms so that you can cancel them individually.
 
=============

You can also add (ding) or (beep) before the (message-box text) but
apparenty not repeated beeps. Does anyone know of some way of doing this
(... while some-condition obtains [the message-box not closed] issue
repeated sounds). In 22.0 there is play-sound and play-sound-file but not
in 21.3.

==============


You might try running Emacs under Cygwin's rxvt, rather than using the
window created by cmd.exe.  As I recall, that's some improvement, but
it's still not perfect.  The best solution that I recall involved
getting a hacked up version of PuTTY
(http://gecko.gc.maricopa.edu/~medgar/puttycyg/), and using that as a
terminal emulator -- it gets the Meta key right.

After saying all that, though, I will confess: I never use the Cygwin
Emacs; instead I use the native Win32 emacs, with cygwin tools -- i.e.,
I put Cygwin on Emacs' path, and run bash as my shell, and have
find-dired-find-program set to 'find.exe', etc.

==============

dired alt route on folders

> Try backward-kill-word, which is bound to M-<backspace> in my version
> of Emacs.  I think that'll do what you want.
>
> --
> -- Steve

C-<backspace> if Backspace is Del. Also hold Ctl down while typing a-k
will delete everything back to the read-only prompt.

==============

> Hmm, without knowing a whole lot about planner, etc., why don't you put 
> multiple notes on (in) a (if I have my terms right) single 'M-x remember' 
> buffer.
>
> (That is essentially what I do in my nedit based (currently) off-line askSam / 
> TWiki workalike thingie.  I use a record separator to separate different 
> notes, and have (fairly) easy-to-use macros to search through the notes in 
> various ways (including folding, to view just the "titles" of the notes).)

> If you want to later put each reminder in a separate buffer (correct 
> terminology?), simply copy and paste from the  'M-x remember' buffer to 
> separate "permanent" buffers.

This sort of thing is actually what happens when you type C-c C-c [or
M-x remember-buffer] while visiting the remember buffer.  Where and how
the note is dispatched is specified by the variable
remember-handler-functions.  If it includes, for example,
remember-append-to-file, the contents of the buffer will be added to a
file similar to what you describe above; if it includes
remember-planner-append, then the note is added to a planner page, after
suitable prompting.

==============

> Jim Ottaway <j.ottaway@lse.ac.uk> writes:
>
>> planner-appt uses planner-cyclic-diary-file to find schedule appointments. A
>> line in that file such as
>>
>> Monday @12:00 lunch
>>
>> in planner-cyclic-diary-file ought to add a schedule entry on Mondays, and set
>> up an appointment alert. It appears to work for me as intended; I have
>> suggested some things for the original poster to try in a separate post.
>>
>
> I see, I didn't know that. It seems quite odd to me to have these two
> modules intertwined like that.

With respect to cyclical schedule appointments, the same file is used
for both tasks and schedule items, but there are no other code
entanglements since planner-cyclic ignores anything in that file that
doesn't look like a task, and planner-appt does the same for schedule
entries. The alternative would be to have two different files, but that
would be a nuisance for the user. And the two things - cyclical tasks
and cyclical schedule items - are conceptually similar anyway.

Hmm. Perhaps the cyclical schedule item code really ought to be in
planner-cyclic? I see I must have thought that before, since I once
added a note about it in planner-appt's TODO comments.

The other part of planner-appt that involves cyclical things is the
forthcoming appointment display. There, the cyclical task file is
examined if planner-cyclic has been required and
planner-appt-forthcoming-look-at-cyclic-flag is non-nil, since then the
user has indicated that they are interested in seeing forthcoming
cyclical appointments. There is some further code entanglement there,
since planner-appt uses the variable
planner-cyclic-task-description-format in its check for duplicate task
appointment items. That would be a bit trickier to disentangle.


============

>> I use planner-appt to remind me the appointments written in .diary,
>> and to show the contents of that file every Monday,Tuseday and so on.
>> following the instructions in planner-appt.el,I add the configuration
>> in my .emacs,I restart my emacs and call "planner-appt-show-alerts"
>> functions, but none is shown in alerts buffer.Nothing happens when
>> the time of appointment is coming.I don't know how to settle this
>> problem.

The first thing to check is that it is not later than the appointment
time when you call planner-appt-show-alerts.  If it is later, no
appointment will be scheduled, of course.

Second, if your diary file really looks like this

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Schedue
Monday @12:00 lunch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

as you say in the original post, then there might be some problem with
the lines with lots of tildes [that's the ~ character], and the one that
looks like "* Schedue", since these are not in the standard diary file
format. Try removing everything except the "Monday @12:00 lunch" line.

Third, it is possible that it doesn't work to use the normal diary file
for such cyclic appointments. If neither of the above explain the
problem, try putting the appointment in the default
planner-cyclic-diary-file file; i.e., remove the setting of that
variable from your configuration and put the appointment into
~/.diary.cyclic-tasks.

============

planner-list-unfinished-tasks M-x planner-list-unfinished-tasks RET
  Command: Display all unfinished tasks on PAGES.

==============

try M-x Muse-index

============

> Ahhhh! So the workflow becomes: have an idea, scribble it down and
> possibly brainstorm, list any hints or rough task breakdown you see,
> all in a note or two, and then use that as the starting point for
> planning and creating tasks. Kind of different from my previous
> workflow (mostly emacs-wiki + allout outline giving a highly
> annotated and hierarchical todo tree; not very pretty, but sort of
> functional). I think I can work with this, cool. I'll experiment and
> tailor further.

That works perfectly too. Add anchors to your outline with # on the
line before it, and you'll be able to easily jump to your hierarchical
notes.

Come to think of it, planner _does_ support hierarchical tasks that
way... <laugh>> 

========
> Although this works, is there a way to make this a global choice
> rather than going and adding it to every page?  I can't help feeling
> that there just has to be, but I haven't been able to find it yet!

(setq emacs-wiki-style-sheet " <link rel=\"stylesheet\" type=\"text/css\" href=\"adds/style.css\">");

works for me.

============
